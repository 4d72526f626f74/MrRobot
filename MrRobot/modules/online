local T, S, H = require('translations'), require('shared'), require('handler')
local Bitfield = require('bitfield')
local VehModels = require('vehicle_models')
local Globals = require('script_globals')
local ScriptOffsets = require('offsets')
local Masks = require('masks')
local Network = require('network')
local Notifications = require('notifications')

local Bits = ScriptOffsets.Online.Bits
local VehicleOffsets = ScriptOffsets.Vehicles.LSCustoms
local Offsets = ScriptOffsets.Online.RequestOffsets
local KosatkaStats = ScriptOffsets.Online.KosatkaStats
local LesterLocate = ScriptOffsets.Online.LesterLocate
local CEOVehicle = ScriptOffsets.Online.CEOVehicle
local SettingsBits = S.SettingsBits

local Settings = pluto_new Bitfield(Bits.ExcludeSelf | Bits.ExcludeFriends)

pluto_class Online
    function __construct(root)
        self.root = root:list(T'Online', {T'ronline'}, '')
        self.properties = {}
        self.tune = menu.ref_by_path('Vehicle>Los Santos Customs>Upgrade')

        for k, v in pairs(S.PropertyIds) do table.insert(self.properties, k) end
        self.properties_data = S:SortTable(self.properties, |a, b| -> a < b)
        self.properties = S:SortTableIndexed(self.properties, |a, b| -> a < b)

        self:CreateFakeNotifs()
        self:CreateServices()
        self:CreateOrganisation()
        self:CreateBounty()
        self:CreateSpoofing()
        self:CreateGhosting()
        self:CreateOther()
        self:CreateCasino()
        self:CreateStoreHoldUps()
        self:CreateTaxiService()
        self:CreateATM()
        self:CreateCargo()
        self:CreateMoney()
        self:CreateYeti()

        self.root:divider('')
        self.root:toggle_loop(T'Anti-Ghosted', {}, T'Prevent other players from becoming ghosted to you', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) and pid ~= players.user() then
                    local entity = S.NewEntity(player.get_player_ped(pid))
                    if entity:is_entity_a_ghost() then
                        Network.SetBounty(pid, -1, true)
                        util.yield_once()
                        Network.SetBounty(pid, -1, false)
                    end
                end
            end
        end)

        self.root:toggle_loop(T'Block Passive Mode', {}, T'Prevent players from going passive', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) and pid ~= players.user() then
                    Network.SetBounty(pid, -1, true)
                end
            end
        end, function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) and pid ~= players.user() then
                    Network.SetBounty(pid, -1, false)
                end
            end
        end)

        self.root:toggle_loop(T'Display Players With BST', {}, T'Show all players that are using BST', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) and pid ~= players.user() then
                    local ped = player.get_player_ped(pid)
                    local ptr = entities.handle_to_pointer(ped)
                    if ptr ~= 0 then
                        local player_info = entities.get_player_info(ptr)
                        if player_info then
                            local weapon_defense = memory.read_float(player_info + 0x0D60)
                            if weapon_defense < 0.99 then
                                util.draw_debug_text(players.get_name(pid) .. ' is using BST')
                            end
                        end
                    end
                end
            end
        end)
    end

    function CreateFakeNotifs()
        self.fake_notifications = self.root:list(T'Fake Notifications', {T'rofakenotif'}, T'Fake Notifications')
        self.fake_notifications:divider(T'Settings')
        self.fn_exclude_me = self.fake_notifications:toggle(T'Exclude Self', {T'notifsexcludeself'}, T'Exclude self from the fake notifications', function(state) 
            Settings:SetBool(Bits.ExcludeSelf, state)
        end, Settings:IsSet(Bits.ExcludeSelf))

        self.fn_exclude_friends = self.fake_notifications:toggle(T'Exclude Friends', {T'notifsexcludefriends'}, T'Exclude friends from the fake notifications', function(state) 
            Settings:SetBool(Bits.ExcludeFriends, state)
        end, Settings:IsSet(Bits.ExcludeFriends))
        self.fake_notifications:divider('')

        local mapping = {
            { name = T'Register CEO', func = S.RegisterCEO, args = nil },
            { name = T'Register MC', func = S.RegisterMC, args = nil },
            { name = T'Register VIP', func = S.RegisterVIP, args = nil },
            { name = T'Off Radar', func = S.OffRadar, args = nil },
            { name = T'Ghost Organisation', func = S.GhostOrg, args = nil },
            { name = T'Successfully Mugged', func = S.SuccessfullyMugged, args = { math.random(math.min_int, math.max_int) } },
            { name = T'Mugger Killed', func = S.MuggerKilled, args = nil },
            { name = T'Jammer Activated', func = S.JammerActivated, args = nil },
            { name = T'Quit Org', func = S.QuitOrg, args = { players.user() } },
            { name = T'Joined Org', func = S.JoinedOrg, args = { players.user() } },
            { name = T'Marked For Death', func = S.MarkedForDeath, args = { players.user() } }
        }

        for mapping as data do
            self.fake_notifications:toggle_loop(T(data.name), {}, '', function()
                if data.args ~= nil then
                    if data.name == T'Successfully Mugged' then data.args = { math.random(math.min_int, math.max_int) } end
                    self:SendNotif(data.func, table.unpack(data.args))
                else
                    self:SendNotif(data.func)
                end
                util.yield(100)
            end)
        end

        self.fake_notifications:divider('')

        for mapping as data do
            self.fake_notifications:action(T(data.name), {}, '', function()
                if data.args ~= nil then
                    if data.name == T'Successfully Mugged' then data.args = { math.random(math.min_int, math.max_int) } end
                    self:SendNotif(data.func, table.unpack(data.args))
                else
                    self:SendNotif(data.func)
                end
                util.yield(100)
            end)
        end

        mapped = nil
    end

    function CreateServices()
        self.services = self.root:list(T'Services', {T'roservices'}, T'Services')
        self.RequestBase = memory.script_global(Globals.RequestBase)
        self.AmPiMenuBase = memory.script_global(Globals.AmPiMenuBase)

        for ({
            { name = T'Request Nano Drone', func = self.RequestService, args = { self, T'NanoDrone' } },
            { name = T'Request RC Bandito', func = self.RequestService, args = { self, T'RCBandito' } },
            { name = T'Request RC Tank', func = self.RequestService, args = { self, T'RCTank' } },
            { name = T'Request MOC', func = self.RequestService, args = { self, T'MOC' } },
            { name = T'Request Avenger', func = self.RequestService, args = { self, T'Avenger' } },
            { name = T'Request Acid Lab', func = self.RequestService, args = { self, T'AcidLab' } },
            { name = T'Request Terrorbyte', func = self.RequestService, args = { self, T'Terrorbyte' } },
            { name = T'Request Dinghy', func = self.RequestService, args = { self, T'Dinghy' } },
            { name = T'Request Kosatka', func = self.RequestService, args = { self, T'Kosatka' } },
            { name = T'Request Sparrow', func = self.RequestService, args = { self, T'Sparrow' } },
            { name = T'Request Avisa', func = self.RequestService, args = { self, T'Avisa' } },
            { name = T'Request Ballistic Armor', func = self.RequestService, args = { self, T'BallisticArmor' } },
            { name = T'Request Ammo Drop', func = self.RequestService, args = { self, T'AmmoDrop' } },
            { name = T'Request Helicopter', func = self.RequestService, args = { self, T'Helicopter' } },
            { name = T'Request Delivery Bike', func = self.RequestService, args = { self, T'DeliveryBike' } },
            { name = T'Request Rat Bike', func = self.RequestService, args = { self, T'RatBike' } },
            { name = T'Request Avenger Thruster', func = self.RequestService, args = { self, T'AvengerThruster' } },
            { name = T'Request Airstrike', func = self.RequestService, args = { self, T'Airstrike' } },
            { name = T'Request Backup Heli', func = self.RequestService, args = { self, T'BackupHeli' } },
            { name = T'Request Bullshark Testosterone', func = self.RequestService, args = { self, T'BST' } },
            { name = T'Request Supplies', func = self.RequestService, args = { self, T'Supplies' } },
            { name = T'Source Motorcycle', func = self.RequestService, args = { self, T'SourceMotorcycle' } }
        }) as data do self.services:action(T(data.name), {T(data.name)}, '', function() data.func(table.unpack(data.args)) end) end

        self.services:divider('')

        for ({
            { name = T'Return Sparrow', func = S:Partial(self.ReturnSparrow, self) },
            { name = T'Return Avisa', func = S:Partial(self.ReturnAvisa, self) },
            { name = T'Return Avenger (Hangar)', func = S:Partial(self.ReturnAvenger, self, 'Hangar') },
            { name = T'Return Avenger (Facility)', func = S:Partial(self.ReturnAvenger, self, 'Facility') },
            { name = T'Return Avenger Thruster', func = S:Partial(self.ReturnAvengerThruster, self) },
            { name = T'Return Delivery Bike', func = S:Partial(self.ReturnDeliveryBike, self) },
            { name = T'Return Acid Lab', func = S:Partial(self.ReturnAcidLab, self) },
            { name = T'Return Kosatka', func = S:Partial(self.ReturnKosatka, self) },
            { name = T'Return Terrorbyte', func = S:Partial(self.ReturnTerrorbyte, self) },
            { name = T'Return MOC', func = S:Partial(self.ReturnMOC, self) },
            { name = T'Return Rat Bike', func = S:Partial(self.ReturnRatBike, self) }
        }) as data do self.services:action(data.name, {data.name}, '', data.func) end

        self.services:divider('')

        for ({
            { name = T'Locate Boat', func = || -> self:LesterLocate(LesterLocate.Boat), desc = T'Get Lester to locate a boat' },
            { name = T'Locate Heli', func = || -> self:LesterLocate(LesterLocate.Heli), desc = T'Get Lester to locate a helicopter' },
            { name = T'Lester Car', func = || -> self:LesterLocate(LesterLocate.Car), desc = T'Get Lester to locate a car' },
            { name = T'Locate Plane', func = || -> self:LesterLocate(LesterLocate.Plane), desc = T'Get Lester to locate a plane' }
        }) as data do self.services:action(data.name, {data.name}, data.desc, data.func) end

        self.services:divider('')

        self.pegasus = self.services:list(T'Pegasus', {T'ropegasus'}, T'Pegasus')
        self.ceo = self.services:list(T'CEO', {T'roceo'}, T'CEO')

        self.pegasus:text_input(T'Vehicle Model', {T'pegasusvehiclemodel'}, T'Enter the model name of the vehicle you want to request', function(model)
            self:RequestPegasusVehicle(model:joaat())
        end, 'adder')

        self.ceo:text_input(T'Vehicle Model', {T'ceovehiclemodel'}, T'Enter the model name of the vehicle you want to request', function(model)
            self:RequestCEOVehicle(model:joaat())
        end, 'adder')

        self.pegasus_models = self.pegasus:list(T'Vehicle Models', {T'vehiclemodels'}, T'Vehicle Models')
        self.ceo_models = self.ceo:list(T'Vehicle Models', {T'vehiclemodels'}, T'Vehicle Models')
        for VehModels as model do
            self.pegasus_models:action(model, {}, model, function()
                self:RequestPegasusVehicle(model:joaat())
            end)
            self.ceo_models:action(model, {}, model, function()
                self:RequestCEOVehicle(model:joaat())
            end)
        end

        self.services:divider('')

        self.services:text_input(T'Rename Acid Lab', {T'rorenameacidlab'}, T'Rename your Acid Lab, what else?', function(name)
            self:RenameAcidLab(name)
        end, self:GetAcidLabName())

        self.money_remover = self.services:list(T'Money Remover', {T'romoneyremover'}, T'Remove money')
        self.money_remover_amount = self.money_remover:text_input(T'Amount', {T'moneyremoveramount'}, T'Amount to remove', function(amount) end, '1')
    
        self.money_remover:action(T'Remove', {T'roremovemoney'}, T'Remove money', function()
            Network.RemoveMoney(tonumber(self.money_remover_amount.value))
        end)

        self.money_remover:toggle_loop(T'Looped Remove', {T'roloopedremove'}, T'Looped money removal', function()
            Network.RemoveMoney(tonumber(self.money_remover_amount.value))
        end)
    end

    function CreateOrganisation()
        self.organisation = self.root:list(T'Organisation', {T'roorganisation'}, T'Organisation')
        self.organisation:toggle_loop(T'Random Name', {T'rorandomname'}, T'Randomise your organisation name', function()
            Network.SetOrganisationName(S:RandomString(98))
        end)

        self.rename_org = self.organisation:text_input(T'Rename', {T'rorenameorg'}, T'', function(name)
            Network.SetOrganisationName(name)
        end, Network.GetOrganisationName())
    end

    function CreateBounty()
        self.bounty = self.root:list(T'Bounty', {T'robounty'}, T'Bounty')
        self.bounty:divider('Bounty Settings')
        self.bounty_amount = self.bounty:text_input(T'Bounty', {T'robountyamount'}, T'How much will someone get for killing the player?', function() end, '10000')
        self.bounty_reward = self.bounty:text_input(T'Reward', {T'robountyreward'}, T'How much will the player get for killing someone? this will override the amount that the player will get (if you set a $1 bounty on someone and set the reward to $10000 they will get $10000 instead of $1)', function() end, '10000')

        self.bounty:divider('Trolling')
        self.set_bounty = self.bounty:action(T'Set Bounty', {T'rosetbountyall'}, T'Set a bounty on the entire session', function()
            local amount = tonumber(self.bounty_amount.value)
            if amount < 0 or amount > 10000 or amount == nil then
                amount = 0
            end
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    Network.SetBounty(pid, amount, true)
                end
            end
        end)

        self.bounty:toggle_loop(T'Loop Bounty', {}, T'Loop set bounties on the entire session', function()
            self.set_bounty:trigger()
        end)

        self.bounty:toggle_loop(T'Set Bounty Reward', {T'rosetbountyall'}, T'Set the bounty reward for the entire session', function()
            local amount = tonumber(self.bounty_amount.value)
            if amount < 0 or amount > 10000 or amount == nil then
                amount = 0
            end
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    Network.SetBountyReward(pid, amount)
                end
            end
        end)

        self.bounty:toggle_loop(T'Max Bounty Reward', {T'romaxbountyreward'}, T'Set bounty reward to maximum for the entire session', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    Network.SetBountyReward(pid, 10000)
                end
            end
        end)
        
        self.bounty:divider('Friendly')
        self.bounty:action(T'Remove Bounty', {T'roremovebountyall'}, T'Remove bounty from entire session', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    Network.SetBounty(pid, 0, false)
                end
            end
        end)

        self.bounty:toggle_loop(T'Remove Bounty Reward', {T'roremovebountyrewardall'}, T'Remove bounty reward for the entire session', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    Network.SetBountyReward(pid, 0)
                end
            end
        end)

        self.bounty:divider('Other')
        self.bounty:toggle_loop(T'Display Bounties', {}, T'Display the bounties of the entire session', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    local bounty = Network.GetBounty(pid)
                    util.draw_debug_text(players.get_name(pid) .. ': ' .. bounty.amount .. ' | ' .. ((Network.IsBountyModded(bounty.amount) and bounty.has_bounty) ? 'Modded' : 'Normal'))
                end
            end
        end)
    end

    function CreateSpoofing()
        self.spoofing = self.root:list(T'Spoofing', {T'rospoofing'}, T'Spoofing')
        self.spoofing:action(T'Spoof Special Property Ownership', {}, T'Spoof ownership of special properties like Kosatka, Terrorbyte etc, this allows you to invite players to someone elses kosatka, terrorbyte', function()
            Network.SpoofSpecialPropertyOwner(players.user())
        end)

        self.hide_from_player_list = self.spoofing:toggle_loop(T'Hide From Player List', {}, T'Hides you from the player list', function()
            Network.HideFromPlayerList(true)
        end, function()
            Network.HideFromPlayerList(false)
        end)

        self.spoofing:divider('')
        self.stats = self.spoofing:list(T'Stat Spoofing', {T'rostats'}, T'Stats')
        self.stat_total_money = self.stats:list(T'Total Money', {}, T'Spoof your total money')
        self.stat_total_wallet = self.stats:list(T'Wallet Money', {}, T'Spoof your wallet money')
        self.stat_rp = self.stats:list(T'RP', {}, T'Spoof your RP')
        self.stat_rank = self.stats:list(T'Rank', {}, T'Spoof your rank')
        self.stat_playerkills = self.stats:list(T'Player Kills', {}, T'Spoof your player kills')
        self.stat_playerdeaths = self.stats:list(T'Player Deaths', {}, T'Spoof your player deaths')
        self.stat_kd = self.stats:list(T'K/D', {}, T'Spoof your K/D')
        self.stat_is_badsport = self.stats:list(T'Is Bad Sport', {}, T'Spoof your bad sport status')
        self.stat_is_cheater = self.stats:list(T'Is Cheater', {}, T'Spoof your cheater status')

        self.stat_total_money:toggle_loop(T'Enable', {}, T'Enable total money spoofing', function()
            Network.SpoofTotalMoney(tonumber(self.total_money.value))
        end)

        self.total_money = self.stat_total_money:text_input(T'Total Money', {T'rosstotalmoney'}, T'Enter the total money you want to spoof', function() end, Network.StatsGetTotalMoney())

        self.stat_total_wallet:toggle_loop(T'Enable', {}, T'Enable wallet money spoofing', function()
            Network.SpoofWallet(tonumber(self.total_wallet.value))
        end)

        self.total_wallet = self.stat_total_wallet:text_input(T'Wallet Money', {T'rosstotalwallet'}, T'Enter the wallet money you want to spoof', function() end, Network.StatsGetWallet())

        self.stat_rp:toggle_loop(T'Enable', {}, T'Enable RP spoofing', function()
            Network.SpoofRP(tonumber(self.rp.value))
        end)

        self.rp = self.stat_rp:text_input(T'RP', {T'rossrp'}, T'Enter the RP you want to spoof', function() end, Network.StatsGetRP())

        self.stat_rank:toggle_loop(T'Enable', {}, T'Enable rank spoofing', function()
            Network.SpoofRank(tonumber(self.rank.value))
        end)

        self.rank = self.stat_rank:text_input(T'Rank', {T'rossrank'}, T'Enter the rank you want to spoof', function() end, Network.StatsGetRank())

        self.stat_playerkills:toggle_loop(T'Enable', {}, T'Enable player kills spoofing', function()
            Network.SpoofKills(tonumber(self.playerkills.value))
        end)

        self.playerkills = self.stat_playerkills:text_input(T'Player Kills', {T'rossplayerkills'}, T'Enter the player kills you want to spoof', function() end, Network.StatsGetKills())

        self.stat_playerdeaths:toggle_loop(T'Enable', {}, T'Enable player deaths spoofing', function()
            Network.SpoofDeaths(tonumber(self.playerdeaths.value))
        end)

        self.playerdeaths = self.stat_playerdeaths:text_input(T'Player Deaths', {T'rossplayerdeaths'}, T'Enter the player deaths you want to spoof', function() end, Network.StatsGetDeaths())

        self.stat_kd:toggle_loop(T'Enable', {}, T'Enable K/D spoofing', function()
            Network.SpoofKD(tonumber(self.kd.value))
        end)

        self.kd = self.stat_kd:text_input(T'K/D', {T'rosskd'}, T'Enter the K/D you want to spoof', function() end, Network.StatsGetKD())

        self.stat_is_badsport:toggle_loop(T'Enable', {}, T'Enable bad sport spoofing', function()
            Network.SpoofIsBadSport(true)
        end, function()
            Network.SpoofIsBadSport(false)
        end)

        self.stat_is_cheater:toggle_loop(T'Enable', {}, T'Enable cheater spoofing', function()
            Network.SpoofIsCheater(true)
        end, function()
            Network.SpoofIsCheater(false)
        end)

        self:UpdateInteriorIndex()
        self.interior_spoofing = self.spoofing:list(T'Interior Spoofing', {T'rointeriorspoofing'}, T'Interior Spoofing', function()
            self:UpdateInteriorIndex()
            self.interior_choice.value = self.interior_index
        end)
        self.interior_choice = self.interior_spoofing:list_select(T'Interior', {T'interiorchoice'}, T'The interior to spoof to', self.properties, self.interior_index, function(_) end)
        self.interior_spoofing:divider('')
        self.interior_spoofing:action(T'Spoof', {T'rospoofinterior'}, T'Spoof to the selected interior', function()
            Network.SetInterior(S.PropertyIds[self.properties_data[self.interior_choice.value]])
        end)

        self.interior_spoofing:toggle_loop(T'Spoof', {T'roloopinteriorspoofing'}, T'Spoof to the selected interior (looped)', function()
            Network.SetInterior(S.PropertyIds[self.properties_data[self.interior_choice.value]])
        end)

        self.interior_spoofing:toggle_loop(T'Random Spoof', {T'roloopinteriorspoofingrand'}, T'Spoof to random interiors constantly', function()
            local rand = math.random(1, #self.properties_data)
            Network.SetInterior(S.PropertyIds[self.properties_data[rand]])
            util.yield(1000)
        end)
    end

    function CreateGhosting()
        self.ghosting = self.root:list(T'Ghosting', {T'roghosting'}, T'Ghosting')
        self.ghosting:toggle(T'All Players', {}, T'Ghost all players in the session', function(state)
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) and pid ~= players.user() then
                    network.set_remote_player_as_ghost(pid, state)
                end
            end
        end)
        self.ghosting:divider('')

        function H.GhostingLoop(pid, root)
            local name = players.get_name(pid)
            if pid ~= players.user() then
                local ref = self.ghosting:refByRelPath(name)
                if not ref:isValid() then
                    self.ghosting:toggle(name, {T'roghost' .. name}, T'Ghost a player', function(state)
                        network.set_remote_player_as_ghost(pid, state)
                    end)
                end
            end
        end

        function H.GhostingRemovePlayer(pid, name)
            if pid ~= players.user() then
                local ref = self.ghosting:refByRelPath(name)
                if ref:isValid() then
                    ref:delete()
                end
            end
        end
    end

    function CreateOther()
        self.other = self.root:list(T'Other', {T'roother'}, T'Other')
        self.other:action(T'Toast The Beast', {}, T'Toast the player who is the beast within the hunt the beast event', function()
            util.spoof_script(Globals.HuntTheBeast, function()
                local beast = Network.GetTheBeast()
                if beast ~= -1 then
                    util.toast(players.get_name(beast) .. ' is the beast')
                end
            end)
        end)

        self.other:action(T'Quick Bail', {}, T'Force yourself to bail from the session', function()
            memory.write_int(memory.script_global(Globals.QuickBail), 5)
        end)
    end

    function CreateCasino()
        self.casino = self.root:list(T'Casino', {T'rocasino'}, T'Casino')
        self.blackjack = self.casino:list(T'Blackjack', {T'rblackjack'}, T'Blackjack')
        self.blackjack:toggle_loop(T'Show Dealer Cards', {}, T'Show the cards of the dealer (it also shows your cards)', function()
            util.spoof_script(Globals.BJScript, function()
                local dealer = memory.script_local(Globals.BJScript, Globals.BlackjackDealerCards)
                local player = memory.script_local(Globals.BJScript, Globals.BlackjackPlayerCards)
                local dealer_cards, player_cards = memory.read_byte(dealer), memory.read_byte(player)
                util.draw_debug_text('Dealer: ' .. dealer_cards .. ' | Player: ' .. player_cards)
            end)
        end)

        self.blackjack:toggle_loop(T'Always Max Bet', {}, T'Always set your bet to max (bypasses limits on lower tables)', function()
            util.spoof_script(Globals.BJScript, function()
                local bet = memory.script_local(Globals.BJScript, Globals.BlackjackBetAmount)
                memory.write_int(bet, 55000)
            end)
        end)
    end

    function UpdateInteriorIndex()
        local current_interior = Network.GetInterior()
        self.interior_index = 1
        for i = 1, #self.properties do
            if S.PropertyIds[self.properties[i]] == current_interior then
                self.interior_index = i
                break
            end
        end
    end

    function CreateStoreHoldUps()
        self.store_holdups = self.root:list(T'Store Holdups', {T'rostoreholdups'}, T'Store Holdups')

        self.force_robbery = self.store_holdups:action(T'Force Robbery', {}, T'Force a robbery when you are inside of a store', function()
            local store = memory.script_local(Globals.HoldUpScript, Globals.HoldUpForceRobbery)
            if store ~= 0 then
                memory.write_int(store, memory.bits:set(memory.read_int(store), Masks.HoldUpForceRobbery))
            end
        end)

        self.instant_finish_robbery = self.store_holdups:action(T'Instant Finish Robbery', {}, T'Instantly finish a robbery when you are inside of a store', function()
            local store = memory.script_local(Globals.HoldUpScript, Globals.HoldUpForceRobbery)
            local scene = memory.script_local(Globals.HoldUpScript, Globals.HoldUpRobberySceneId)
            if store ~= 0 and scene ~= 0 then
                memory.write_int(store, memory.bits:set(memory.read_int(store), Masks.HoldUpForceRobbery))
                local scene_id = memory.read_int(scene)
                repeat
                    util.yield_once()
                    scene_id = memory.read_int(scene)
                until scene_id ~= -1
                repeat
                    util.yield_once()
                until ped.is_synchronized_scene_running(scene_id)
                ped.set_synchronized_scene_phase(scene_id, 100.0)
            end
        end)
    end

    function CreateTaxiService()
        local Script = Globals.TaxiScript
        self.taxi = self.root:list(T'Taxi Service', {T'rtaxi'}, T'Taxi Service')

        self.taxi:action(T'Instant Quit', {}, T'Instantly quit the taxi service', function()
            local quit = memory.script_local(Script, Globals.TaxiServiceInstantQuit)
            if quit ~= 0 then
                memory.write_int(quit, 2)
            end
        end)

        self.taxi:text_input(T'Fare', {T'taxiservicefare'}, T'Set the fare for the taxi service', function(fare)
            local fare = memory.script_local(Script, Globals.TaxiServiceFare)
            if fare ~= 0 then
                memory.write_int(fare, tonumber(fare))
            end
        end)

        self.taxi:text_input(T'Tip', {T'taxiservicetip'}, T'Set the tip for the taxi service', function(tip)
            local tip = memory.script_local(Script, Globals.TaxiServiceTip)
            if tip ~= 0 then
                memory.write_int(tip, tonumber(tip))
            end
        end)

        self.taxi:toggle_loop(T'Disable Customer Salt', {}, T'Prevent the customer from getting mad at you and decreasing the tip, crashing will still cause the customer to get mad at you though!', function()
            local salt = memory.script_local(Script, Globals.TaxiServiceSaltTimerActive)
            if salt ~= 0 then
                memory.write_int(salt, 0)
            end
        end)

        self.taxi:toggle_loop(T'Remove Fare', {}, T'Remove the fare', function()
            local fare = memory.script_local(Script, Globals.TaxiServiceFare)
            if fare ~= 0 then
                memory.write_int(fare, 0)
            end
        end)

        self.taxi:toggle_loop(T'Remove Tip', {}, T'Remove the tip', function()
            local tip = memory.script_local(Script, Globals.TaxiServiceTip)
            if tip ~= 0 then
                memory.write_int(tip, 0)
            end
        end)

        self.taxi:toggle_loop(T'Max Tip', {}, T'Set the tip to the maximum value', function()
            local fare = memory.script_local(Script, Globals.TaxiServiceFare)
            local tip = memory.script_local(Script, Globals.TaxiServiceTip)
            if fare ~= 0 and tip ~= 0 then
                memory.write_int(fare, 0)
                memory.write_int(tip, 15000)
            end
        end)
    end

    function CreateATM()
        self.atm = self.root:list(T'ATM', {T'roatm'}, T'ATM')
        self.atm:action(T'Deposit', {T'rtdepall'}, T'Deposits all money into your bank', || -> Network.TransferToBank())
        self.atm:divider('')
        self.atm:toggle_loop(T'Auto Deposit', {T'rtautodepall'}, T'Automatically deposit all money in your wallet to bank', || -> Network.TransferToBank())
        self.atm:text_input(T'Deposit Amount', {T'rtdepamount'}, T'Amount of money to deposit into your bank from wallet', |amount| -> Network.TransferToBank(tonumber(amount)))
    end

    function CreateCargo()
        self.crates_amount = nil
        local cargo_amount = 50
        local crate_type = 0
        self.cargo = self.root:list(T'Cargo', {T'rocargo'}, T'Cargo')

        self.cargo:list_select(T'Crate Type', {T'rocargotype'}, T'The type of crate to source', {
            {1, 'Animal Materials'},
            {2, 'Art & Antiques'},
            {3, 'Chemicals'},
            {4, 'Counterfeit Goods'},
            {5, 'Jewelry & Gemstones'},
            {6, 'Medical Supplies'},
            {7, 'Narcotics'},
            {8, 'Tobacco & Alcohol'},
            {9, 'Cargo'}
        }, 1, function(index)
            crate_type = index - 1
        end)

        self.cargo:text_input(T'Crates', {T'rocargoamount'}, T'Amount of cargo to source', function(amount) 
            cargo_amount = amount
        end, '50')
        self.cargo:toggle_loop(T'Display Crates', {T'rodisplaycrates'}, T'Display the amount of crates in your hangar', function()
            local total_crates = memory.script_global(Globals.HangarTotalCargo)
            util.draw_debug_text($'Crates: {memory.read_int(total_crates)}')
        end)
        self.cargo:divider('')

        self.cargo:action(T'Instant Source', {}, T'Instantly source cargo for air freight', function()
            local source = memory.script_global(Globals.InstantSourceHangarCargo)
            local total_crates = memory.script_global(Globals.HangarCratesToSource)
            local cargo_type = memory.script_global(Globals.HangarCrateType)
            local total_cargo = memory.script_global(Globals.HangarTotalCargo)

            if (memory.read_int(total_cargo) < 50) then
                memory.write_int(total_crates, cargo_amount)
                memory.write_int(cargo_type, crate_type)
                memory.write_int(source, memory.bits:toggle(memory.read_int(source), 1 << 9))
                util.yield(800)
                memory.write_int(source, memory.bits:toggle(memory.read_int(source), 1 << 9))
            else
                Notifications.Show('Your hangar is full, unable to source more cargo', 'Air Freight', '', Notifications.HUD_COLOUR_REDDARK)
            end
        end)

        self.cargo:action(T'Launch App', {T'roappsmugler'}, T'Remotely open air freight internt application', function()
            S:StartNewScript(Globals.AppSmuggler)
        end)
    end

    function CreateMoney()
        self.money = self.root:list(T'Money (RISKY)', {T'romoney'}, T'Money')
        self.money.visible = false
        table.insert(S.RiskyRefs, self.money)

        local cayo = self.money:list(T'Cayo Perico', {}, T'Money from cayo perico heist')
        local casino = self.money:list(T'Casino', {}, T'Money from casino heist')

        cayo:action(T'Maximum (2.55M)', {}, T'Get the maximum amount of money that you can get from the heist', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_ISLAND_HEIST_FINALE'), 2550000)
        end)

        cayo:action(T'Legit (900K - 1.9M)', {}, T'Get a reasonable amount of money from the heist that seems more legit', function()
            local choices = {900000, 1000000, 1100000, 1300000, 1900000}
            local choice = choices[math.random(#choices)]
            local amount = choice - (choice * 0.12000000000000001)
            S:TriggerTransaction(util.joaat('SERVICE_EARN_ISLAND_HEIST_FINALE'), amount)
        end)

        casino:action(T'Maximum (3.55M)', {}, T'Get the maximum amount of money that you can get from the heist', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_CASINO_HEIST_FINALE'), 3550000)
        end)

        casino:toggle_loop(T'Member Bonus Loop (5K Chips)', {}, '', function()
            memory.write_byte(memory.script_global(Globals.CasinoChipsMemBonus), 1)
            util.yield_once()    
        end)

        self.money:divider('')
        self.money:action(T'Criminal Mastermind (10M)', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_JOB_BONUS_CRIMINAL_MASTERMIND'), 10000000)
        end)

        self.money:action(T'180K', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_JOBS'), 180000)
        end)

        self.money:action(T'200K', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_COLLECTABLE_COMPLETED_COLLECTION'), 200000)
        end)

        self.money:action(T'680K', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_BETTING'), 680000)
        end)

        self.money:action(T'25K', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_AMBIENT_JOB_SMUGGLER_PLANE'), 25000)
        end)
        
        self.money:action(T'Salvage Yard (1.5M)', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_SALVAGE_YARD_SELL_VEH'), 1500000)
        end)

        self.money:divider('')

        self.money:toggle_loop(T'180K Loop', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_JOBS'), 180000)
        end)

        self.money:toggle_loop(T'200K Loop', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_COLLECTABLE_COMPLETED_COLLECTION'), 200000)
        end)

        self.money:toggle_loop(T'680K Loop', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_BETTING'), 680000)
        end)
    end

    function CreateYeti()
        self.yeti = self.root:list(T'Yeti', {T'royeti'}, T'Yeti')
        self.yeti:toggle(T'Event State', {}, T'Enable/disable yeti event', function(state)
            memory.write_int(memory.script_global(Globals.YetiEventEnable), state and 1 or 0)
        end, memory.read_int(memory.script_global(Globals.YetiEventEnable)) == 1)

        self.yeti:toggle(T'Big RP', {}, T'Increase RP so you get a total of 450,000 from investigate all clues button below', function(state)
            memory.write_float(memory.script_global(262145 + 1), state and 90 or 1)
        end)

        self.yeti:toggle(T'Disable RP', {}, T'Disable RP so you don\'t get any from investigating all clues', function(state)
            memory.write_float(memory.script_global(262145 + 1), state and 0 or 1)
        end)

        self.yeti:action(T'Investigate All Clues', {}, T'Investigate all the clues instantly', function()
            local addr = memory.script_local(Globals.FMScript, Globals.YetiCluesBitfield)
            local bitfield = pluto_new Bitfield(memory.read_int(addr), addr)
            memory.write_int(memory.script_global(Globals.YetiEventEnable), 1)
            memory.write_int(memory.script_global(Globals.YetiClueReward), 0)

            bitfield:Set(0x203)
            local timeout = os.time() + 2
            util.create_tick_handler(function()
                memory.write_int(memory.script_local(Globals.FMScript, Globals.YetiCluesCollected), 5)
                if os.time() > timeout then
                    return false
                end
            end)

            for i = 0, 5 do
                bitfield:Set(1 << 2)
                util.yield(50)
                bitfield:Clear(1 << 2)
                util.yield(200)
            end

            memory.write_int(memory.script_global(Globals.YetiClueReward), 10000)
        end)
        self.yeti:divider('')

        self.yeti:action(T'Teleport To Bloodied Tent', {}, '', function()
            local localplayer = players.localplayer()
            localplayer:set_entity_coords_no_offset(-1562.69, 4699.04, 50.426, false, false, false)
        end)

        self.yeti:action(T'Teleport To Torn Shirt', {}, '', function()
            local localplayer = players.localplayer()
            localplayer:set_entity_coords_no_offset(-1359.869, 4733.429, 46.919, false, false, false)
        end)

        self.yeti:action(T'Teleport To Deer', {}, '', function()
            local localplayer = players.localplayer()
            localplayer:set_entity_coords_no_offset(-1715.398, 4501.203, 0.096, false, false, false)
        end)

        self.yeti:action(T'Teleport To Body Parts', {}, '', function()
            local localplayer = players.localplayer()
            localplayer:set_entity_coords_no_offset(-1567.8599, 4478.6294, 20.928696, false, false, false)
        end)

        self.yeti:action(T'Teleport To Chiliad Wilderness', {}, '', function()
            local localplayer = players.localplayer()
            localplayer:set_entity_coords_no_offset(-1345.828, 4838.062, 137.522, false, false, false)
        end)
    end

    function ReturnSparrow()
        local stats = memory.script_global(Globals.KosatkaStatsBase)
        local value = memory.read_byte(stats)
        value = memory.bits:clear(value, KosatkaStats.ReturnSparrow)
        memory.write_byte(stats, value)
    end

    function ReturnAvisa()
        local stats = memory.script_global(Globals.KosatkaStatsBase)
        local value = memory.read_byte(stats)
        value = memory.bits:clear(value, KosatkaStats.ReturnAvisa)
        memory.write_byte(stats, value) 
    end

    function ReturnAvenger(location)
        local stats = memory.script_global(Globals.AvengerStatsBase)
        local stats1 = stats - (4 << 3)
        local value = memory.read_int(stats)
        memory.write_int(stats, memory.bits:set(memory.read_int(stats), 1 << 20))
        util.yield(10)
        memory.write_int(stats, memory.bits:clear(memory.read_int(stats), 1 << 20))
        if location == 'Hangar' then
            memory.write_int(stats1, memory.bits:clear(memory.read_int(stats1), 1 << 6))
        elseif location == 'Facility' then
            memory.write_int(stats1, memory.bits:set(memory.read_int(stats1), 1 << 6))
        end
        memory.write_int(stats1, memory.bits:set(memory.read_int(stats), 1 << 3))
        memory.write_int(stats, memory.bits:set(memory.read_int(stats), 1 << 16))
        util.yield(10)
        memory.write_int(stats1, memory.bits:clear(memory.read_int(stats), 1 << 3))
    end

    function ReturnAvengerThruster()
        local blip = hud.get_first_blip_info_id(597)
        if blip ~= 0 then
            local entity = hud.get_blip_info_id_entity_index(blip)
            if entity ~= 0 then
                entities.delete_by_handle(entity)
            end
        end
    end

    function ReturnDeliveryBike()
        local blip = hud.get_first_blip_info_id(348)
        if blip ~= 0 then
            local entity = hud.get_blip_info_id_entity_index(blip)
            if entity ~= 0 then
                local stats = memory.script_global(Globals.AcidLabStatsBase)
                memory.write_short(stats, memory.bits:clear(memory.read_short(stats), 1 << 6))
                memory.write_short(stats, memory.bits:set(memory.read_short(stats), 0x300))
                entities.delete_by_handle(entity)
            end
        end
    end

    function ReturnAcidLab()
        local blip = hud.get_first_blip_info_id(840)
        if blip ~= 0 then
            local entity = hud.get_blip_info_id_entity_index(blip)
            if entity ~= 0 then
                local stats = memory.script_global(Globals.AcidLabStatsBase)
                local stats1 = stats - 0x8
                memory.write_int(stats1, memory.bits:set(memory.read_int(stats), 1 << 26))
                memory.write_int(stats, memory.bits:clear(memory.read_int(stats), 1 << 0))
                memory.write_int(stats, memory.bits:set(memory.read_int(stats1), 0x100002))
                entities.delete_by_handle(entity)
            end
        end
    end

    function ReturnKosatka()
        local kosatka = memory.script_global(Globals.ReturnKosatka)
        local kosatka1 = kosatka + 0x8
        memory.write_byte(kosatka, 2)
        memory.write_byte(kosatka1, 17)
    end

    function ReturnTerrorbyte()
        local blip = hud.get_first_blip_info_id(632)
        if blip ~= 0 then
            local entity = hud.get_blip_info_id_entity_index(blip)
            if entity ~= 0 then
                local stats = memory.script_global(Globals.TerrorbyteStatsBase)
                memory.write_int(stats, memory.bits:set(memory.read_int(stats), 0x18000090))
                memory.write_int(stats, memory.bits:clear(memory.read_int(stats), 1 << 11))
                entities.delete_by_handle(entity)
            end
        end
    end

    function ReturnMOC()
        -- credit to Acjoker for helping with figuring out how to return the MOC
        local blip = hud.get_first_blip_info_id(564)
        if blip ~= 0 then
            local entity = hud.get_blip_info_id_entity_index(blip)
            if entity ~= 0 then
                local stats = memory.script_global(Globals.MOCStatsBase)
                local stats1 = stats + 0x8
                memory.write_int(stats, memory.bits:set(memory.read_int(stats), 0x100040))
                memory.write_int(stats, memory.bits:clear(memory.read_int(stats), 1 << 5))
                memory.write_int(stats1, memory.bits:clear(memory.read_int(stats), 0x2100001))
                memory.write_int(stats1, memory.bits:clear(memory.read_int(stats), 1 << 8))
            end
        end
    end

    function ReturnRatBike()
        local  blip = hud.get_first_blip_info_id(348)
        if blip ~= 0 then
            local entity = hud.get_blip_info_id_entity_index(blip)
            if entity ~= 0 then
                entities.delete_by_handle(entity)
            end
        end
    end

    function RequestService(service)
        switch service do
            case 'NanoDrone':
                local drone = memory.script_global(Globals.RequestNanoDrone)
                memory.write_int(drone, memory.read_int(drone) | Masks.RequestNanoDrone)
                break
            case 'RCBandito':
                memory.write_byte(self.RequestBase + Offsets.Bandito, 1)
                break
            case 'RCTank':
                memory.write_byte(self.RequestBase + Offsets.Tank, 1)
                util.yield(3500)
                self.tune:trigger()
                break
            case 'MOC':
                memory.write_byte(self.RequestBase + Offsets.MOC, 1)
                break
            case 'Avenger':
                memory.write_byte(self.RequestBase + Offsets.Avenger, 1)
                break
            case 'AcidLab':
                memory.write_byte(self.RequestBase + Offsets.AcidLab, 1)
                break
            case 'Terrorbyte':
                memory.write_byte(self.RequestBase + Offsets.Terrorbyte, 1)
                break
            case 'Dinghy':
                memory.write_byte(self.RequestBase + Offsets.Dinghy, 1)
                break
            case 'Kosatka':
                memory.write_byte(self.RequestBase + Offsets.Kosatka, 1)
                break
            case 'Sparrow':
                memory.write_byte(self.AmPiMenuBase + Offsets.Sparrow, 1)
                break
            case 'Avisa':
                memory.write_byte(self.AmPiMenuBase + Offsets.Avisa, 1)
                break
            case 'BallisticArmor':
                memory.write_byte(self.RequestBase + Offsets.BallisticArmor, 1)
                break
            case 'AmmoDrop':
                memory.write_byte(self.RequestBase + Offsets.AmmoDrop, 1)
                break
            case 'Helicopter':
                memory.write_byte(self.RequestBase + Offsets.Helicopter, 1)
                break
            case 'DeliveryBike':
                memory.write_byte(self.RequestBase + Offsets.DeliveryBike, 1)
                break
            case 'RatBike':
                memory.write_byte(self.AmPiMenuBase + Offsets.RatBike, 1)
                break
            case 'AvengerThruster':
                memory.write_byte(self.AmPiMenuBase + Offsets.AvengerThruster, 1)
                break
            case 'Airstrike':
                stats.set_packed_stat_bool_code(8, true, util.get_char_slot())
                memory.write_byte(self.RequestBase + Offsets.Airstrike, 1)
                break
            case 'BackupHeli':
                stats.set_packed_stat_bool_code(11, true, util.get_char_slot())
                memory.write_byte(self.RequestBase + Offsets.BackupHeli, 1)
                break
            case 'BST':
                memory.write_byte(self.RequestBase + Offsets.BST, 1)
                break
            case 'Supplies':
                local supplies = memory.script_global(Globals.RequestSupplies)
                local timer = memory.script_global(Globals.RequestSuppliesTimer)
                memory.write_short(supplies, memory.read_short(supplies) | Masks.RequestSupplies)
                util.yield(500)
                memory.write_int(timer, 0)
                break
            case 'SourceMotorcycle':
                memory.write_byte(memory.script_global(Globals.SourceMotorcycle), 1)
                break

        end
    end

    function SendNotif(func, ...)
        for pid = 0, players.max_players do
            if S:PlayerExists(pid) then
                if Settings:IsSet(Bits.ExcludeSelf) and pid == players.user() then
                    goto continue
                elseif Settings:IsSet(Bits.ExcludeFriends) and S:IsFriend(pid) then
                    goto continue
                end
                func(S, pid, ...)
            end
            ::continue::
        end
    end

    function LesterLocate(bit)
        local lester = memory.script_global(Globals.LesterLocate)
        memory.write_byte(lester, memory.bits:toggle(memory.read_byte(lester), bit))
        util.yield_once()
        memory.write_byte(lester, memory.bits:toggle(memory.read_byte(lester), bit))
    end

    function RequestPegasusVehicle(hash)
        -- credit to acjoker for finding the globals that made this possible
        if not streaming.is_model_valid(hash) then util.toast('Invalid model hash') return end
        local request = memory.script_global(Globals.PegasusRequest)
        local request1 = request + 0x8
        memory.write_int(request1, hash)
        memory.write_byte(request, memory.bits:toggle(memory.read_byte(request), 1 << 7))
        util.yield_once()
        memory.write_byte(request, memory.bits:toggle(memory.read_byte(request), 1 << 7))
    end

    function RequestCEOVehicle(hash)
        if not streaming.is_model_valid(hash) then util.toast('Invalid model hash') return end
        local request = memory.script_global(Globals.OrganisationBase + 10)
        memory.write_int(request + CEOVehicle.VehicleHash, hash)
        memory.write_byte(request + CEOVehicle.Request, 1)
    end

    function RenameAcidLab(name)
        memory.write_string(memory.script_global(Globals.AcidLabName), name)
    end
    
    function GetAcidLabName()
        return memory.read_string(memory.script_global(Globals.AcidLabName))
    end
end

return Online
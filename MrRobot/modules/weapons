local T, S = require('translations'), require('shared')
local WeaponsList = require('weapons_list')

local sns_ammo_types = {'Default Clip', 'Extended Clip', 'Tracer', 'Incendiary', 'Hollow Point', 'FMJ'}
local heavy_revolver_types = {'Default Clip', 'Tracer', 'Incendiary', 'Hollow Point', 'FMJ'}
local special_carbine_types = {'Default Clip', 'Extended Clip', 'Tracer', 'Incendiary', 'FMJ', 'Armor Piercing'}
local bullpup_rifle_types = {'Default Clip', 'Extended Clip', 'Tracer', 'Incendiary', 'FMJ', 'Armor Piercing'}
local pump_shotgun_types = {'Default Shells', 'Dragons Breathe', 'Flechette Shells', 'Steel Buckshot Shells', 'Explosive Slugs'}
local marksman_rifle_types = {'Default Clip', 'Extended Clip', 'Tracer', 'Incendiary', 'FMJ', 'Armor Piercing'}
local pistol_types = {'Default Clip', 'Extended Clip', 'Tracer', 'Incendiary', 'Hollow Point', 'FMJ'}
local smg_types = {'Default Clip', 'Extended Clip', 'Tracer', 'Incendiary', 'Hollow Point', 'FMJ'}
local assault_rifle_types = {'Default Clip', 'Extended Clip', 'Tracer', 'Incendiary', 'FMJ', 'Armor Piercing'}
local carbine_rifle_types = {'Default Clip', 'Extended Clip', 'Tracer', 'Incendiary', 'FMJ', 'Armor Piercing'}
local combat_mg_types = {'Default Clip', 'Extended Clip', 'Tracer', 'Incendiary', 'FMJ', 'Armor Piercing'}
local heavy_sniper_types = {'Default Clip', 'Extended Clip', 'Incendiary', 'FMJ', 'Armor Piercing', 'Explosive'}

local heavy_sniper_scopes = {'Zoom Scope', 'Advanced Scope', 'Night Vision Scope', 'Thermal Scope'}
local all_types = {
    ['SNS Pistol'] = sns_ammo_types,
    ['Heavy Revolver'] = heavy_revolver_types,
    ['Special Carbine'] = special_carbine_types,
    ['Bullpup Rifle'] = bullpup_rifle_types,
    ['Pump Shotgun'] = pump_shotgun_types,
    ['Marksman Rifle'] = marksman_rifle_types,
    ['Pistol'] = pistol_types,
    ['SMG'] = smg_types,
    ['Assault Rifle'] = assault_rifle_types,
    ['Carbine Rifle'] = carbine_rifle_types,
    ['Combat MG'] = combat_mg_types,
    ['Heavy Sniper'] = heavy_sniper_types
}

local weapons_hashmap = {
    ['SNS Pistol'] = util.joaat('WEAPON_SNSPISTOL_MK2'),
    ['Heavy Revolver'] = util.joaat('WEAPON_REVOLVER_MK2'),
    ['Special Carbine'] = util.joaat('WEAPON_SPECIALCARBINE_MK2'),
    ['Bullpup Rifle'] = util.joaat('WEAPON_BULLPUPRIFLE_MK2'),
    ['Pump Shotgun'] = util.joaat('WEAPON_PUMPSHOTGUN_MK2'),
    ['Marksman Rifle'] = util.joaat('WEAPON_MARKSMANRIFLE_MK2'),
    ['Pistol'] = util.joaat('WEAPON_PISTOL_MK2'),
    ['SMG'] = util.joaat('WEAPON_SMG_MK2'),
    ['Assault Rifle'] = util.joaat('WEAPON_ASSAULTRIFLE_MK2'),
    ['Carbine Rifle'] = util.joaat('WEAPON_CARBINERIFLE_MK2'),
    ['Combat MG'] = util.joaat('WEAPON_COMBATMG_MK2'),
    ['Heavy Sniper'] = util.joaat('WEAPON_HEAVYSNIPER_MK2')
}

local weapons_names = {
    'None',
    'SNS Pistol',
    'Heavy Revolver',
    'Special Carbine',
    'Bullpup Rifle',
    'Pump Shotgun',
    'Marksman Rifle',
    'Pistol',
    'SMG',
    'Assault Rifle',
    'Carbine Rifle',
    'Combat MG',
    'Heavy Sniper'
}

local damage_types = {
    'Melee',
    'Bullet',
    'Bullet Rubber',
    'Explosive',
    'Fire',
    'Collision',
    'Fall',
    'Drown',
    'Electric',
    'Barbed Wire',
    'Fire Extinguisher',
    'Smoke',
    'Water Cannon',
    'Tranquilizer'
}

local special_ammo = {
    'None',
    'Armor Piercing',
    'Explosive',
    'FMJ',
    'Hollow Point',
    'Incendiary',
    'Tracer'
}

pluto_class Weapons
    function __construct(root)
        self.root = root:list(T'Weapons', {T'rweapons'}, '')
        self.mk2 = self.root:list(T'MK2', {T'rweaponsmk2'}, T'MK2 weapons')
        self.thermal = self.root:list(T'Thermal', {T'rthermal'}, T'Thermal')
        self.aimbot = self.root:list(T'Aimbot', {T'raimbot'}, T'Aimbot')
        self.mods = self.root:list(T'Mods', {T'rmods'}, T'Mods')

        self:CreateMk2Weapons()
        self:CreateThermal()
        self:CreateAimbot()
        self:CreateMods()
    end

    function CreateMk2Weapons()
        self.mk2:list_select(T'Weapons', {}, T'Weapon to modify', weapons_names, 1, function(index)
            if not SCRIPT_CAN_CONTINUE then return end
            if self.mk2:isValid() then
                for self.mk2:getChildren() as child do
                    if child:isValid() then
                        if child.menu_name ~= T'Weapons' then
                            child:delete()
                        end
                    end
                end
            end

            local weapon = weapons_names[index]
            local weapon_hash = weapons_hashmap[weapon]
            local ammo_types = all_types[weapon]

            if index ~= 1 then
                if weapon ~= 'Heavy Sniper' then
                    self.mk2:list_select(T'Ammo', {}, '', ammo_types, 1, function(index)
                        local ammo_type = self:AmmoTypeToHash(ammo_types[index], weapon_hash)
                        self:GiveComponent(weapon_hash, ammo_type)
                    end)
                else
                    self.mk2:list_select(T'Ammo', {}, '', ammo_types, 1, function(index)
                        local ammo_type = self:AmmoTypeToHash(ammo_types[index], weapon_hash)
                        self:GiveComponent(weapon_hash, ammo_type)
                    end)

                    local scope = self.mk2:list_select(T'Scope', {}, '', heavy_sniper_scopes, 1, function(index)
                        local scope = heavy_sniper_scopes[index]
                        local component_hash = ''
                        if scope == 'Zoom Scope' then
                            component_hash = util.joaat('COMPONENT_AT_SCOPE_LARGE_MK2')
                        elseif scope == 'Advanced Scope' then
                            component_hash = util.joaat('COMPONENT_AT_SCOPE_MAX')
                        elseif scope == 'Night Vision Scope' then
                            component_hash = util.joaat('COMPONENT_AT_SCOPE_NV')
                        elseif scope == 'Thermal Scope' then
                            component_hash = util.joaat('COMPONENT_AT_SCOPE_THERMAL')
                        end
                        self:GiveComponent(weapon_hash, component_hash)
                    end)
                end
            end
        end)
    end

    function CreateThermal()
        self.thermal:toggle_loop(T'ESP Thermal', {}, T'Makes thermal more op than it already is', function()
            if graphics.get_usingseethrough() then
                graphics.seethrough_set_max_thickness(graphics.seethrough_get_max_thickness())
                graphics.seethrough_set_noise_min(0.0)
                graphics.seethrough_set_noise_max(0.0)
                graphics.seethrough_set_fade_startdistance(0.0)
                graphics.seethrough_set_fade_enddistance(math.max_int + 0.0)
                graphics.seethrough_set_highlight_noise(0.0)
            else
                graphics.seethrough_reset()
            end
        end,
        function()
            graphics.seethrough_reset()
        end)
    end

    function CreateAimbot()
        do pluto_new (require('ped_aimbot'))(self.aimbot) end
        do pluto_new (require('player_aimbot'))(self.aimbot) end
    end

    function CreateMods()
        self.mods:toggle_loop(T'Double Tap', {}, T'Shoot 2 bullets instead of 1', function()
            if not SCRIPT_CAN_CONTINUE then return end
            memory.write_int(self:GetCurrentWeapon() + 0x0120, 2)
        end, function()
            if not SCRIPT_CAN_CONTINUE then return end
            memory.write_int(self:GetCurrentWeapon() + 0x0120, 1)
        end)

        self.mods:toggle_loop(T'Fast Reload', {}, T'Reload super fast', function()
            if not SCRIPT_CAN_CONTINUE then return end
            memory.write_float(self:GetCurrentWeapon() + 0x0134, 2.0)
        end, function()
            if not SCRIPT_CAN_CONTINUE then return end
            memory.write_float(self:GetCurrentWeapon() + 0x0134, 1.5)
        end)

        -- self.mods:toggle_loop(T'Infinite Range', {}, T'Be able to shoot very long distances regardless of the weapon you have', function()
        --     if not SCRIPT_CAN_CONTINUE then return end
        --     memory.write_float(self:GetCurrentWeapon() + 0x028C, math.max_int / 2)
        -- end, function()
        --     if not SCRIPT_CAN_CONTINUE then return end
        --     memory.write_float(self:GetCurrentWeapon() + 0x028C, 1500.0)
        -- end)

        self.mods:toggle_loop(T'No Spread', {}, T'No spread', function()
            if not SCRIPT_CAN_CONTINUE then return end
            memory.write_float(self:GetCurrentWeapon() + 0x0074, 0.0)
        end, function()
            if not SCRIPT_CAN_CONTINUE then return end
            memory.write_float(self:GetCurrentWeapon() + 0x00D0, 3.0)
        end)

        self.mods:toggle_loop(T'Max Penetration', {}, T'', function()
            if not SCRIPT_CAN_CONTINUE then return end
            memory.write_float(self:GetCurrentWeapon() + 0x0110, 100.0)
        end, function()
            if not SCRIPT_CAN_CONTINUE then return end
            memory.write_float(self:GetCurrentWeapon() + 0x0110, 1.0)
        end)

        self.mods:divider('')

        self.mods:slider(T'Bullets Multiplier', {}, T'How many bullets to shoot per shot', 1, 1000, 1, 1, function(value)
            if not SCRIPT_CAN_CONTINUE then return end
            memory.write_int(self:GetCurrentWeapon() + 0x0120, value)
        end)

        self.mods:slider_float(T'Vehicle Damage Modifier', {T'rwvehdamagemod'}, T'How much damage to do to vehicles', 0.0, 100000.0 * 100, 1.0 * 100, 1.0 * 10, function(value)
            if not SCRIPT_CAN_CONTINUE then return end
            memory.write_float(self:GetCurrentWeapon() + 0x00D4, value / 100)
        end)

        self.damage_type = self.mods:list(T'Damage Type', {}, T'What type of damage to do (not all of these work on players)')
        self.damage_type:list_select(T'Type', {}, T'Type of damage your weapon deals', damage_types, 1, function(index)
            if not SCRIPT_CAN_CONTINUE then return end
            memory.write_int(self:GetCurrentWeapon() + 0x0020, index + 1)
        end)

        self.special_ammo = self.mods:list(T'Special Ammo', {}, T'Equip special ammo on any gun (explosive will trigger explosive hits detection)')
        self.special_ammo:list_select(T'Type', {}, T'Type of special ammo to equip', special_ammo, 1, function(index)
            if not SCRIPT_CAN_CONTINUE then return end
            memory.write_int(self:GetCurrentWeaponAmmoInfo() + 0x003C, index - 1)
        end)
    end

    function AmmoTypeToHash(type, weapon)
        local weapon_name = util.reverse_joaat(weapon)
        weapon_name = weapon_name:gsub('WEAPON_', '')

        local comp = 'COMPONENT_' .. weapon_name .. '_CLIP_'

        if type == 'Default Clip' or type == 'Default Shells' then
            return util.joaat(comp .. '01')
        elseif type == 'Extended Clip' then
            return util.joaat(comp .. '02')
        elseif type == 'Tracer' then
            return util.joaat(comp .. 'TRACER')
        elseif type == 'Incendiary' then
            return util.joaat(comp .. 'INCENDIARY')
        elseif type == 'Hollow Point' then
            return util.joaat(comp .. 'HOLLOWPOINT')
        elseif type == 'FMJ' then
            return util.joaat(comp .. 'FMJ')
        elseif type == 'Explosive' then
            return util.joaat(comp .. 'EXPLOSIVE')
        elseif type == 'Armor Piercing' then
            return util.joaat(comp .. 'ARMORPIERCING')
        elseif type == 'Dragons Breathe' then
            return util.joaat(comp .. 'INCENDIARY')
        elseif type == 'Flechette Shells' then
            return util.joaat(comp .. 'HOLLOWPOINT')
        elseif type == 'Steel Buckshot Shells' then
            return util.joaat(comp .. 'ARMORPIERCING')
        elseif type == 'Explosive Slugs' then
            return util.joaat(comp .. 'EXPLOSIVE')
        end
    end

    function GiveComponent(weapon_hash, component_hash)
        if not SCRIPT_CAN_CONTINUE then return end
        local localplayer = players.localplayer()
        if not localplayer:has_ped_got_weapon_component(weapon_hash, component_hash) then
            localplayer:give_weapon_component_to_ped(weapon_hash, component_hash)
            local ammo_type = localplayer:get_ped_ammo_type_from_weapon(weapon_hash)
            localplayer:set_ped_ammo_by_type(ammo_type, 9999)
        end
    end

    function GetCurrentWeapon()
        local weapon_manager = entities.get_weapon_manager(entities.handle_to_pointer(players.user_ped()))
        local current_weapon = memory.read_long(weapon_manager + 0x0020)
        return current_weapon
    end

    function GetCurrentWeaponAmmoInfo()
        return memory.read_long(self:GetCurrentWeapon() + 0x0060)
    end
end

return Weapons
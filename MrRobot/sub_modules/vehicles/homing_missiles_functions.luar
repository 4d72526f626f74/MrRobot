--[[
    Credit to Wiri for all functionality within this file.
]]

local json = soup.json
local self = {}

local write_global = {
    byte = function(global, value)
        local address = memory.script_global(global)
        memory.write_byte(address, value)
    end,
    int = function(global, value)
        local address = memory.script_global(global)
        memory.write_int(address, value)
    end,
    float = function(global, value)
        local address = memory.script_global(global)
        memory.write_float(address, value)
    end
}


local read_global = {
    byte = function(global)
        local address = memory.script_global(global)
        return memory.read_byte(address)
    end,
    int = function(global)
        local address = memory.script_global(global)
        return memory.read_int(address)
    end,
    float = function(global)
        local address = memory.script_global(global)
        return memory.read_float(address)
    end,
    string = function(global)
        local address = memory.script_global(global)
        return memory.read_string(address)
    end
}

local Config = {
    controls = {
        vehicleweapons = 86,
        airstrikeaircraft = 86
    },
    general = {
        standnotifications = false,
        displayhealth = true,
        language = "english",
        developer = false, 	-- developer flag (enables/disables some debug features)
        showintro = true
    },
    ufo = {
        disableboxes = false, 	-- determines if boxes are drawn on players to show their position
        targetplayer = false 	-- wether tractor beam only targets players or not
    },
    vehiclegun = {
        disablepreview = false,
    },
    healthtxtpos = {
        x = 0.03,
        y = 0.05
    },
    handlingAutoload = {}
}

---@alias HudColour integer

local HudColour =
{
    pureWhite = 0,
    white = 1,
    black = 2,
    grey = 3,
    greyLight = 4,
    greyDrak = 5,
    red = 6,
    redLight = 7,
    redDark = 8,
    blue = 9,
    blueLight = 10,
    blueDark = 11,
    yellow = 12,
    yellowLight = 13,
    yellowDark = 14,
    orange = 15,
    orangeLight = 16,
    orangeDark = 17,
    green = 18,
    greenLight = 19,
    greenDark = 20,
    purple = 21,
    purpleLight = 22,
    purpleDark = 23,
    radarHealth = 25,
    radarArmour = 26,
    friendly = 118,
}

local NULL <const> = 0

--------------------------
-- NOTIFICATION
--------------------------

---@class Notification
local notification =
{
    txdDict = "DIA_ZOMBIE1",
    txdName = "DIA_ZOMBIE1",
    title = "WiriScript",
    subtitle = "~c~" .. util.get_label_text("PM_PANE_FEE") .. "~s~",
    defaultColour = HudColour.black
}

---@param msg string
function notification.stand(msg)
    assert(type(msg) == "string", "msg must be a string, got " .. type(msg))
    msg = msg:gsub('~[%w_]-~', ""):gsub('<C>(.-)</C>', '%1')
    util.toast("[WiriScript] " .. msg)
end


---@param format string
---@param colour? HudColour
function notification:help(format, colour, ...)
    assert(type(format) == "string", "msg must be a string, got " .. type(format))

    local msg = string.format(format, ...)
    if Config.general.standnotifications then
        return self.stand(msg)
    end

    HUD.THEFEED_SET_BACKGROUND_COLOR_FOR_NEXT_POST(colour or self.defaultColour)
    util.BEGIN_TEXT_COMMAND_THEFEED_POST("~BLIP_INFO_ICON~ " .. msg)
    HUD.END_TEXT_COMMAND_THEFEED_POST_TICKER_WITH_TOKENS(true, true)
end


---@param format string
---@param colour? HudColour
function notification:normal(format, colour, ...)
    assert(type(format) == "string", "msg must be a string, got " .. type(format))

    local msg = string.format(format, ...)
    if Config.general.standnotifications then
        return self.stand(msg)
    end

    HUD.THEFEED_SET_BACKGROUND_COLOR_FOR_NEXT_POST(colour or self.defaultColour)
    util.BEGIN_TEXT_COMMAND_THEFEED_POST(msg)
    HUD.END_TEXT_COMMAND_THEFEED_POST_MESSAGETEXT(self.txdDict, self.txdName, true, 4, self.title, self.subtitle)
    HUD.END_TEXT_COMMAND_THEFEED_POST_TICKER(false, false)
end

--------------------------
-- MENU
--------------------------

local Features = {}
local Translation = {}

---@param section string
---@param name string
---@return string
function translate(section, name)
    Features[section] = Features[section] or {}
    Features[section][name] = Features[section][name] or ""
    if Config.general.language == "english" then
        return name
    end
    Translation[section] = Translation[section] or Features[section]
    if not Translation[section][name] then
        Translation[section][name] = ""
        return name
    end
    if Translation[section][name] == "" then
        return name
    end
    return Translation[section][name]
end


---@param value any
---@param e string
function type_match (value, e)
    local t = type(value)
    for w in e:gmatch('[^|]+') do
        if t == w then return true end
    end
    local msg = "must be %s, got %s"
    return false, msg:format(e:gsub('|', " or "), t)
end


---@param tbl table
---@param types {[1]: string, [2]:string}
---@return boolean
---@return string? errmsg
local check_table_types = function (tbl, types)
    if type(tbl) ~= "table" then
        return false, "tbl must be a tble"
    end
    for key, value in pairs(tbl) do
        local ok, errmsg = type_match(key, types[1])
        if not ok then return false, "field " .. key .. ' ' .. errmsg end

        local ok, errmsg = type_match(value, types[2])
        if not ok then return false, "field " .. key .. ' ' .. errmsg end
    end
    return true
end


---@param obj table
---@return boolean
---@return string? errmsg
function is_translation_valid (obj)
    for sect_name, section in pairs(obj) do
        if type(sect_name) ~= "string" then
            return false, "got unexpected key type: " .. type(sect_name)
        end

        if type(section) ~= "table" then
            return false, "field " .. sect_name .. " must be a table, got " .. type(section)
        end

        local ok, err = check_table_types(section, {"string", "string"})
        if not ok then return false, err end
    end
    return true
end


---@param language string
---@return boolean
---@return string? errmsg
function load_translation(language)
    local path = filesystem.scripts_dir() .. "WiriScript\\language\\" .. language
    if not filesystem.exists(path) then
        return false, "no such a file"
    end

    local ok, result = json.parse(path, false)
    if not ok then
        return false, result
    end

    local ok, errmsg = is_translation_valid(result)
    if not ok then
        return false, errmsg
    end

    Translation = result
    util.log("Translation file successfully loaded: %s", language)
    return true
end

--------------------------
-- FILE
--------------------------

local Ini = {}

---Saves a table with key-value pairs in an ini format file.
---@param fileName string
---@param obj table
function Ini.save(fileName, obj)
    local file <close> = assert(io.open(fileName, "w"), "error loading file")
    local s = {}
    for section, tbl in pairs(obj) do
        assert(type(tbl) == "table", "expected field " .. section .. " to be a table, got " .. type(tbl))
        local l = {}
        table.insert(l, string.format("[%s]", section))
        for k, v in pairs(tbl) do table.insert(l, string.format("%s=%s", k, v)) end
        table.insert(s, table.concat(l, '\n') .. '\n')
    end
    file:write(table.concat(s, '\n'))
end


---Parses a table from an ini format file.
---@param fileName any
---@return table
function Ini.load(fileName)
    assert(type(fileName) == "string", "fileName must be a string")
    local file <close> = assert(io.open(fileName, "r"), "error loading file: " .. fileName)
    local data = {}
    local section
    for line in io.lines(fileName) do
        local tempSection = string.match(line, '^%[([^%]]+)%]$')

        if tempSection ~= nil then
            section = tonumber(tempSection) and tonumber(tempSection) or tempSection
            data[section] = data[section] or {}
        end

        local param, value = string.match(line, '^([%w_]+)%s*=%s*(.+)$')
        if section ~= nil and param and value ~= nil then
            if value == "true" then
                value = true
            elseif value == "false" then
                value = false
            elseif tonumber(value) then
                value = tonumber(value)
            end
            data[section][tonumber(param) or param] = value
        end
    end
    return data
end


local parseJson = json.parse

---@param filePath string
---@param withoutNull? boolean
---@return boolean
---@return string|table
json.parse = function (filePath, withoutNull)
    local file <close> = assert(io.open(filePath, "r"), filePath .. " does not exist")
    local content = file:read("a")
    local fileName = string.match(filePath, '^.+\\(.+)')
    if #content == 0 then
        return false,  fileName .. " is empty"
    end
    return pcall(parseJson, content, withoutNull)
end

--------------------------
-- EFFECT
--------------------------

---@class Effect
local Effect = {asset = "", name = "", scale = 1.0}
Effect.__index = Effect

---@param asset string
---@param name string
---@param scale? number
---@return Effect
function Effect.new(asset, name, scale)
    local inst = setmetatable({}, Effect)
    inst.name = name
    inst.asset = asset
    inst.scale = scale
    return inst
end

--------------------------
-- SOUND
--------------------------

---@class Sound
local Sound = {Id = -1, name = "", reference = ""}
Sound.__index = Sound

---@alias nullptr 0

---@param name string|nullptr
---@param reference string|nullptr
---@return Sound
function Sound.new(name, reference)
    local inst = setmetatable({}, Sound)
    inst.name = name
    inst.reference = reference
    return inst
end

function Sound:play()
    if self.Id == -1 then
        self.Id = AUDIO.GET_SOUND_ID()
        AUDIO.PLAY_SOUND_FRONTEND(self.Id, self.name, self.reference, true)
    end
end

function Sound:stop()
    if self.Id ~= -1 then
        AUDIO.STOP_SOUND(self.Id)
        AUDIO.RELEASE_SOUND_ID(self.Id)
        self.Id = -1
    end
end

function Sound:hasFinished()
    return AUDIO.HAS_SOUND_FINISHED(self.Id)
end

function Sound:playFromEntity(entity)
    if self.Id == -1 then
        self.Id = AUDIO.GET_SOUND_ID()
        AUDIO.PLAY_SOUND_FROM_ENTITY(self.Id, self.name, entity, self.reference, true, 0)
    end
end

--------------------------
-- COLOUR
--------------------------

---@class Colour
---@field r number | integer
---@field g number | integer
---@field b number | integer
---@field a number | integer

function new_colour(r, g, b, a)
    return {r = r, g = g, b = b, a = a}
end


---@return Colour
function get_random_colour()
    local colour = {a = 255}
    colour.r = math.random(0,255)
    colour.g = math.random(0,255)
    colour.b = math.random(0,255)
    return colour
end


---@param hudColour HudColour
---@return {r: integer, g: integer, b: integer, a: integer}
function get_hud_colour(hudColour)
    local r = memory.alloc(1)
    local g = memory.alloc(1)
    local b = memory.alloc(1)
    local a = memory.alloc(1)
    HUD.GET_HUD_COLOUR(hudColour, r, g, b, a)
    return {r = memory.read_int(r), g = memory.read_int(g), b = memory.read_int(b), a = memory.read_int(a)}
end


---@param colour Colour
function rainbow_colour(colour)
    if colour.r > 0 and colour.b == 0 then
        colour.r = colour.r - 1
        colour.g = colour.g + 1
    end

    if colour.g > 0 and colour.r == 0 then
        colour.g = colour.g - 1
        colour.b = colour.b + 1
    end

    if colour.b > 0 and colour.g == 0 then
        colour.r = colour.r + 1
        colour.b = colour.b - 1
    end
end


---@param perc number
---@return Colour
function get_blended_colour(perc)
    local colour = {a = 255}
    local r, g, b

    if perc <= 0.5 then
        r = 1.0
        g = interpolate(0.0, 1.0, perc/0.5)
        b = 0.0
    else
        r = interpolate(1.0, 0, (perc - 0.5)/0.5)
        g = 1.0
        b = 0.0
    end

    colour.r = math.ceil(r * 255)
    colour.g = math.ceil(g * 255)
    colour.b = math.ceil(b * 255)
    return colour
end

--------------------------
-- INSTRUCTIONAL
--------------------------

local Instructional = {scaleform = 0}

---@return boolean
function Instructional:begin ()
    if GRAPHICS.HAS_SCALEFORM_MOVIE_LOADED(self.scaleform) then
        GRAPHICS.BEGIN_SCALEFORM_MOVIE_METHOD(self.scaleform, "CLEAR_ALL")
        GRAPHICS.END_SCALEFORM_MOVIE_METHOD()

        GRAPHICS.BEGIN_SCALEFORM_MOVIE_METHOD(self.scaleform, "TOGGLE_MOUSE_BUTTONS")
        GRAPHICS.SCALEFORM_MOVIE_METHOD_ADD_PARAM_BOOL(true)
        GRAPHICS.END_SCALEFORM_MOVIE_METHOD()

        self.position = 0
        return true
    else
        self.scaleform = request_scaleform_movie("instructional_buttons")
        return false
    end
end


---@param index integer
---@param name string
---@param button string
function Instructional:add_data_slot(index, name, button)
    GRAPHICS.BEGIN_SCALEFORM_MOVIE_METHOD(self.scaleform, "SET_DATA_SLOT")
    GRAPHICS.SCALEFORM_MOVIE_METHOD_ADD_PARAM_INT(self.position)

    GRAPHICS.SCALEFORM_MOVIE_METHOD_ADD_PARAM_PLAYER_NAME_STRING(button)
    if HUD.DOES_TEXT_LABEL_EXIST(name) then
        GRAPHICS.BEGIN_TEXT_COMMAND_SCALEFORM_STRING(name)
        GRAPHICS.END_TEXT_COMMAND_SCALEFORM_STRING()
    else
        GRAPHICS.SCALEFORM_MOVIE_METHOD_ADD_PARAM_TEXTURE_NAME_STRING(name)
    end
    GRAPHICS.SCALEFORM_MOVIE_METHOD_ADD_PARAM_BOOL(false)
    GRAPHICS.SCALEFORM_MOVIE_METHOD_ADD_PARAM_INT(index)
    GRAPHICS.END_SCALEFORM_MOVIE_METHOD()
    self.position = self.position + 1
end


---@param index integer
---@param name string
function Instructional.add_control(index, name)
    local button = PAD.GET_CONTROL_INSTRUCTIONAL_BUTTONS_STRING(2, index, true)
    Instructional:add_data_slot(index, name, button)
end


---@param index integer
---@param name string
function Instructional.add_control_group (index, name)
    local button = PAD.GET_CONTROL_GROUP_INSTRUCTIONAL_BUTTONS_STRING(2, index, true)
    Instructional:add_data_slot(index, name, button)
end


---@param r integer
---@param g integer
---@param b integer
---@param a integer
function Instructional:set_background_colour(r, g, b, a)
    GRAPHICS.BEGIN_SCALEFORM_MOVIE_METHOD(self.scaleform, "SET_BACKGROUND_COLOUR")
    GRAPHICS.SCALEFORM_MOVIE_METHOD_ADD_PARAM_INT(r)
    GRAPHICS.SCALEFORM_MOVIE_METHOD_ADD_PARAM_INT(g)
    GRAPHICS.SCALEFORM_MOVIE_METHOD_ADD_PARAM_INT(b)
    GRAPHICS.SCALEFORM_MOVIE_METHOD_ADD_PARAM_INT(a)
    GRAPHICS.END_SCALEFORM_MOVIE_METHOD()
end


function Instructional:draw ()
    GRAPHICS.BEGIN_SCALEFORM_MOVIE_METHOD(self.scaleform, "DRAW_INSTRUCTIONAL_BUTTONS")
    GRAPHICS.END_SCALEFORM_MOVIE_METHOD()

    GRAPHICS.DRAW_SCALEFORM_MOVIE_FULLSCREEN(self.scaleform, 255, 255, 255, 220, 0)
    self.position = 0
end

--------------------------
-- TIMER
--------------------------

---@class Timer
---@field elapsed fun(): integer
---@field reset fun()
---@field isEnabled fun(): boolean
---@field disable fun()

---@return Timer
function newTimer()
    local self = {
        start = util.current_time_millis(),
        m_enabled = false,
    }

    local function reset()
        self.start = util.current_time_millis()
        self.m_enabled = true
    end

    local function elapsed()
        return util.current_time_millis() - self.start
    end

    local function disable() self.m_enabled = false end
    local function isEnabled() return self.m_enabled end

    return
    {
        isEnabled = isEnabled,
        reset = reset,
        elapsed = elapsed,
        disable = disable,
    }
end

--------------------------
-- ENTITIES
--------------------------

function SetBit(bits, place)
    return (bits | (1 << place))
end

function ClearBit(bits, place)
    return (bits & ~(1 << place))
end

function BitTest(bits, place)
    return (bits & (1 << place)) ~= 0
end


---@param entity Entity
---@param value boolean
function set_explosion_proof(entity, value)
    local pEntity = entities.handle_to_pointer(entity)
    if pEntity == 0 then return end
    local damageBits = memory.read_uint(pEntity + 0x188)
    damageBits = value and SetBit(damageBits, 11) or ClearBit(damageBits, 11)
    memory.write_uint(pEntity + 0x188, damageBits)
end


---@param entity Entity
---@param target Entity
---@param usePitch? boolean
function set_entity_face_entity(entity, target, usePitch)
    local pos1 = ENTITY.GET_ENTITY_COORDS(entity, false)
    local pos2 = ENTITY.GET_ENTITY_COORDS(target, false)
    local rel = v3.new(pos2)
    rel:sub(pos1)
    local rot = rel:toRot()
    if not usePitch then
        ENTITY.SET_ENTITY_HEADING(entity, rot.z)
    else
        ENTITY.SET_ENTITY_ROTATION(entity, rot.x, rot.y, rot.z, 2, false)
    end
end


---@param entity Entity
---@param blipSprite integer
---@param colour integer
---@return Blip
function add_blip_for_entity(entity, blipSprite, colour)
    local blip = HUD.ADD_BLIP_FOR_ENTITY(entity)
    HUD.SET_BLIP_SPRITE(blip, blipSprite)
    HUD.SET_BLIP_COLOUR(blip, colour)
    HUD.SHOW_HEIGHT_ON_BLIP(blip, false)

    util.create_tick_handler(function ()
        if not ENTITY.DOES_ENTITY_EXIST(entity)or ENTITY.IS_ENTITY_DEAD(entity, false) then
            util.remove_blip(blip)
            return false
        elseif not HUD.DOES_BLIP_EXIST(blip) then
            return false
        else
            local heading = ENTITY.GET_ENTITY_HEADING(entity)
            HUD.SET_BLIP_ROTATION(blip, math.ceil(heading))
        end
    end)

    return blip
end


---@param blip Blip
---@param name string
---@param isLabel? boolean
function set_blip_name(blip, name, isLabel)
    HUD.BEGIN_TEXT_COMMAND_SET_BLIP_NAME("STRING")
    if not isLabel then
        HUD.ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(name)
    else
        HUD.ADD_TEXT_COMPONENT_SUBSTRING_TEXT_LABEL(name)
    end
    HUD.END_TEXT_COMMAND_SET_BLIP_NAME(blip)
end


---@param entity Entity
---@return boolean
function request_control_once(entity)
    if not NETWORK.NETWORK_IS_IN_SESSION() then
        return true
    end
    local netId = NETWORK.NETWORK_GET_NETWORK_ID_FROM_ENTITY(entity)
    NETWORK.SET_NETWORK_ID_CAN_MIGRATE(netId, true)
    return NETWORK.NETWORK_REQUEST_CONTROL_OF_ENTITY(entity)
end


---@param entity Entity
---@param timeOut? integer #time in `ms` trying to get control
---@return boolean
function request_control(entity, timeOut)
    if not ENTITY.DOES_ENTITY_EXIST(entity) then
        return false
    end
    timeOut = timeOut or 500
    local start = newTimer()
    while not request_control_once(entity) and start.elapsed() < timeOut do
        util.yield_once()
    end
    return start.elapsed() < timeOut
end


---@param ped Ped
---@param maxPeds? integer
---@param ignore? integer
---@return Entity[]
function get_ped_nearby_peds(ped, maxPeds, ignore)
    maxPeds = maxPeds or 16
    local pEntityList = memory.alloc((maxPeds + 1) * 8)
    memory.write_int(pEntityList, maxPeds)
    local pedsList = {}
    for i = 1, PED.GET_PED_NEARBY_PEDS(ped, pEntityList, ignore or -1), 1 do
        pedsList[i] = memory.read_int(pEntityList + i*8)
    end
    return pedsList
end


---@param ped Ped
---@param maxVehicles? integer
---@return Entity[]
function get_ped_nearby_vehicles(ped, maxVehicles)
    maxVehicles = maxVehicles or 16
    local pVehicleList = memory.alloc((maxVehicles + 1) * 8)
    memory.write_int(pVehicleList, maxVehicles)
    local vehiclesList = {}
    for i = 1, PED.GET_PED_NEARBY_VEHICLES(ped, pVehicleList) do
        vehiclesList[i] = memory.read_int(pVehicleList + i*8)
    end
    return vehiclesList
end


---@param ped Ped
---@return Entity[]
function get_ped_nearby_entities(ped)
    local peds = get_ped_nearby_peds(ped)
    local vehicles = get_ped_nearby_vehicles(ped)
    local entities = peds
    for i = 1, #vehicles do table.insert(entities, vehicles[i]) end
    return entities
end


---@param player Player
---@param radius number
---@return Entity[]
function get_peds_in_player_range(player, radius)
    local peds = {}
    local playerPed = PLAYER.GET_PLAYER_PED_SCRIPT_INDEX(player)
    local pos = players.get_position(player)
    for _, ped in ipairs(entities.get_all_peds_as_handles()) do
        if ped ~= playerPed and not PED.IS_PED_FATALLY_INJURED(ped) then
            local pedPos = ENTITY.GET_ENTITY_COORDS(ped, true)
            if pos:distance(pedPos) <= radius then table.insert(peds, ped) end
        end
    end
    return peds
end


---@param player Player
---@param radius number
---@return Entity[]
function get_vehicles_in_player_range(player, radius)
    local vehicles = {}
    local pos = players.get_position(player)
    for _, vehicle in ipairs(entities.get_all_vehicles_as_handles()) do
        local vehPos = ENTITY.GET_ENTITY_COORDS(vehicle, true)
        if pos:distance(vehPos) <= radius then table.insert(vehicles, vehicle) end
    end
    return vehicles
end


---@param pId Player
---@param radius number
---@return Entity[]
function get_entities_in_player_range(pId, radius)
    local peds = get_peds_in_player_range(pId, radius)
    local vehicles = get_vehicles_in_player_range(pId, radius)
    local entities = peds
    for i = 1, #vehicles do table.insert(entities, vehicles[i]) end
    return entities
end


---@param start v3
---@param to v3
---@param colour Colour
local draw_line = function (start, to, colour)
    GRAPHICS.DRAW_LINE(start.x, start.y, start.z, to.x, to.y, to.z, colour.r, colour.g, colour.b, colour.a)
end


---@param pos0 v3
---@param pos1 v3
---@param pos2 v3
---@param pos3 v3
---@param colour Colour
local draw_rect = function (pos0, pos1, pos2, pos3, colour)
    GRAPHICS.DRAW_POLY(pos0.x, pos0.y, pos0.z, pos1.x, pos1.y, pos1.z, pos3.x, pos3.y, pos3.z, colour.r, colour.g, colour.b, colour.a)
    GRAPHICS.DRAW_POLY(pos3.x, pos3.y, pos3.z, pos2.x, pos2.y, pos2.z, pos0.x, pos0.y, pos0.z, colour.r, colour.g, colour.b, colour.a)
end


---@param entity Entity
---@param showPoly? boolean
---@param colour? Colour	
function draw_bounding_box(entity, showPoly, colour)
    if not ENTITY.DOES_ENTITY_EXIST(entity) then
        return
    end
    colour = colour or {r = 255, g = 0, b = 0, a = 255}
    local min = v3.new()
    local max = v3.new()
    MISC.GET_MODEL_DIMENSIONS(ENTITY.GET_ENTITY_MODEL(entity), min, max)
    min:abs(); max:abs()

    local upperLeftRear = ENTITY.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS(entity, -max.x, -max.y, max.z)
    local upperRightRear = ENTITY.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS(entity, min.x, -max.y, max.z)
    local lowerLeftRear = ENTITY.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS(entity, -max.x, -max.y, -min.z)
    local lowerRightRear = ENTITY.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS(entity, min.x, -max.y, -min.z)

    draw_line(upperLeftRear, upperRightRear, colour)
    draw_line(lowerLeftRear, lowerRightRear, colour)
    draw_line(upperLeftRear, lowerLeftRear, colour)
    draw_line(upperRightRear, lowerRightRear, colour)

    local upperLeftFront = ENTITY.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS(entity, -max.x, min.y, max.z)
    local upperRightFront = ENTITY.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS(entity, min.x, min.y, max.z)
    local lowerLeftFront = ENTITY.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS(entity, -max.x, min.y, -min.z)
    local lowerRightFront = ENTITY.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS(entity, min.x, min.y, -min.z)

    draw_line(upperLeftFront, upperRightFront, colour)
    draw_line(lowerLeftFront, lowerRightFront, colour)
    draw_line(upperLeftFront, lowerLeftFront, colour)
    draw_line(upperRightFront, lowerRightFront, colour)

    draw_line(upperLeftRear, upperLeftFront, colour)
    draw_line(upperRightRear, upperRightFront, colour)
    draw_line(lowerLeftRear, lowerLeftFront, colour)
    draw_line(lowerRightRear, lowerRightFront, colour)

    if type(showPoly) ~= "boolean" or showPoly then
        draw_rect(lowerLeftRear, upperLeftRear, lowerLeftFront, upperLeftFront, colour)
        draw_rect(upperRightRear, lowerRightRear, upperRightFront, lowerRightFront, colour)

        draw_rect(lowerLeftFront, upperLeftFront, lowerRightFront, upperRightFront, colour)
        draw_rect(upperLeftRear, lowerLeftRear, upperRightRear, lowerRightRear, colour)

        draw_rect(upperRightRear, upperRightFront, upperLeftRear, upperLeftFront, colour)
        draw_rect(lowerRightFront, lowerRightRear, lowerLeftFront, lowerLeftRear, colour)
    end
end


---@param entity Entity
---@param flag integer
function set_decor_flag(entity, flag)
    DECORATOR.DECOR_SET_INT(entity, "Casino_Game_Info_Decorator", flag)
end


---@param entity Entity
---@param flag integer
---@return boolean
function is_decor_flag_set(entity, flag)
    if ENTITY.DOES_ENTITY_EXIST(entity) and
    DECORATOR.DECOR_EXIST_ON(entity, "Casino_Game_Info_Decorator") then
        local value = DECORATOR.DECOR_GET_INT(entity, "Casino_Game_Info_Decorator")
        return (value & flag) ~= 0
    end
    return false
end


---@param entity Entity
function remove_decor(entity)
    DECORATOR.DECOR_REMOVE(entity, "Casino_Game_Info_Decorator")
end


---@param ped Ped
---@param forcedOn boolean
---@param hasCone boolean
---@param noticeRange number
---@param colour integer
---@param sprite integer
function add_ai_blip_for_ped(ped, forcedOn, hasCone, noticeRange, colour, sprite)
    if colour == -1 then
        HUD.SET_PED_HAS_AI_BLIP(ped, true)
    else
        HUD.SET_PED_HAS_AI_BLIP_WITH_COLOUR(ped, true, colour)
    end
    HUD.SET_PED_AI_BLIP_NOTICE_RANGE(ped, noticeRange)
    if sprite ~= -1 then HUD.SET_PED_AI_BLIP_SPRITE(ped, sprite) end
    HUD.SET_PED_AI_BLIP_HAS_CONE(ped, hasCone)
    HUD.SET_PED_AI_BLIP_FORCED_ON(ped, forcedOn)
end


---@param entity Entity
---@param minDistance number
---@param maxDistance number
---@return v3
function get_random_offset_from_entity(entity, minDistance, maxDistance)
    local pos = ENTITY.GET_ENTITY_COORDS(entity, false)
    return get_random_offset_in_range(pos, minDistance, maxDistance)
end


---@param coords v3
---@param minDistance number
---@param maxDistance number
---@return v3
function get_random_offset_in_range(coords, minDistance, maxDistance)
    local radius = random_float(minDistance, maxDistance)
    local angle = random_float(0, 2 * math.pi)
    local delta = v3.new(math.cos(angle), math.sin(angle), 0.0)
    delta:mul(radius)
    coords:add(delta)
    return coords
end


---@param entity Entity
function set_entity_as_no_longer_needed(entity)
    if not ENTITY.DOES_ENTITY_EXIST(entity) then return end
    local pHandle = memory.alloc_int()
    memory.write_int(pHandle, entity)
    ENTITY.SET_ENTITY_AS_NO_LONGER_NEEDED(pHandle)
end


---@param entity Entity
---@param target Entity
---@return number
function get_distance_between_entities(entity, target)
    if not ENTITY.DOES_ENTITY_EXIST(entity) or not ENTITY.DOES_ENTITY_EXIST(target) then
        return 0.0
    end
    local pos = ENTITY.GET_ENTITY_COORDS(entity, true)
    return ENTITY.GET_ENTITY_COORDS(target, true):distance(pos)
end

--------------------------
-- PLAYER
--------------------------

---@param player Player
---@return boolean
function is_player_friend(player)
    local pHandle = memory.alloc(104)
    NETWORK.NETWORK_HANDLE_FROM_PLAYER(player, pHandle, 13)
    local isFriend = NETWORK.NETWORK_IS_HANDLE_VALID(pHandle, 13) and NETWORK.NETWORK_IS_FRIEND(pHandle)
    return isFriend
end


---@param player Player
---@return Vehicle
function get_vehicle_player_is_in(player)
    local targetPed = PLAYER.GET_PLAYER_PED_SCRIPT_INDEX(player)
    if PED.IS_PED_IN_ANY_VEHICLE(targetPed, false) then
        return PED.GET_VEHICLE_PED_IS_IN(targetPed, false)
    end
    return 0
end


---@param player Player
---@return Entity
function get_entity_player_is_aiming_at(player)
    if not PLAYER.IS_PLAYER_FREE_AIMING(player) then
        return NULL
    end
    local entity, pEntity = NULL, memory.alloc_int()
    if PLAYER.GET_ENTITY_PLAYER_IS_FREE_AIMING_AT(player, pEntity) then
        entity = memory.read_int(pEntity)
    end
    if entity ~= NULL and ENTITY.IS_ENTITY_A_PED(entity) and PED.IS_PED_IN_ANY_VEHICLE(entity, false) then
        entity = PED.GET_VEHICLE_PED_IS_IN(entity, false)
    end
    return entity
end


---@param entity Entity
---@return integer address
function get_net_obj(entity)
    local pEntity = entities.handle_to_pointer(entity)
    return pEntity ~= NULL and memory.read_long(pEntity + 0xD0) or NULL
end


---@param entity Entity
---@return Player owner
function get_entity_owner(entity)
    local net_obj = get_net_obj(entity)
    return net_obj ~= NULL and memory.read_byte(net_obj + 0x49) or -1
end


---@param player Player
---@return boolean
function is_player_passive(player)
    if player ~= players.user() then
        local address = memory.script_global(1887305 + (player * 610 + 1) + 8) -- Global_1887305[PLAYER::PLAYER_ID() /*610*/].f_8
        if address ~= NULL then return memory.read_byte(address) == 1 end
    else
        return false
    end
    return false
end


---@param player Player
---@return boolean
function is_player_in_any_interior(player)
    return INTERIOR.GET_INTERIOR_FROM_ENTITY(PLAYER.GET_PLAYER_PED_SCRIPT_INDEX(player)) ~= 0
end


---@param player Player
---@return boolean
function is_player_in_interior(player)
    if player == -1 then
        return false
    end
    return INTERIOR.GET_INTERIOR_FROM_ENTITY(PLAYER.GET_PLAYER_PED_SCRIPT_INDEX(player)) ~= 0
end


---@param player Player
---@return boolean
function is_player_in_rc_bandito(player)
    if player ~= -1 then
        local ped = PLAYER.GET_PLAYER_PED_SCRIPT_INDEX(player)
        local veh = VEHICLE.GET_VEHICLE_PED_IS_IN(ped, false)

        if veh ~= 0 then
            local model = ENTITY.GET_ENTITY_MODEL(veh)
            return model == util.joaat("rcbandito")
        end
    end
    return false
end


---@param player Player
---@return boolean
function is_player_in_rc_tank(player)
    if player ~= -1 then
        local ped = PLAYER.GET_PLAYER_PED_SCRIPT_INDEX(player)
        local veh = VEHICLE.GET_VEHICLE_PED_IS_IN(ped, false)

        if veh ~= 0 then
            local model = ENTITY.GET_ENTITY_MODEL(veh)
            return model == util.joaat("minitank")
        end
    end
    return false
end


---@param player Player
---@return boolean
function is_player_in_rc_personal_vehicle(player)
    if player ~= -1 then
        -- local address = memory.script_global(1853910 + (player * 862 + 1) + 267 + 428 + 3)
        -- return BitTest(memory.read_int(address), 6)
        return false
    end
    return false
end


---@param player Player
---@return boolean
function is_player_in_any_rc_vehicle(player)
    return players.is_using_rc_vehicle(player)
end


---@diagnostic disable: exp-in-action, unknown-symbol, action-after-return, undefined-global
---@param colour integer
---@return integer
function get_hud_colour_from_org_colour(colour)
    switch colour do
        case 0:
            return 192
        case 1:
            return 193
        case 2:
            return 194
        case 3:
            return 195
        case 4:
            return 196
        case 5:
            return 197
        case 6:
            return 198
        case 7:
            return 199
        case 8:
            return 200
        case 9:
            return 201
        case 10:
            return 202
        case 11:
            return 203
        case 12:
            return 204
        case 13:
            return 205
        case 14:
            return 206
    end
    return 1
end


---@diagnostic enable: exp-in-action, unknown-symbol, action-after-return, undefined-global
---@param player Player
---@return integer
function get_player_org_blip_colour(player)
    if players.get_boss(player) ~= -1 then
        local hudColour = get_hud_colour_from_org_colour(players.get_org_colour(player))
        local rgba = get_hud_colour(hudColour)
        return (rgba.r << 24) + (rgba.g << 16) + (rgba.b << 8) + rgba.a
    end
    return 0
end


---@param player Player
---@return string
function get_condensed_player_name(player)
    local condensed = "<C>" .. PLAYER.GET_PLAYER_NAME(player) .. "</C>"

    if players.get_boss(player) ~= -1  then
        local colour = players.get_org_colour(player)
        local hudColour = get_hud_colour_from_org_colour(colour)
        return string.format("~HC_%d~%s~s~", hudColour, condensed)
    end

    return condensed
end


---@param player Player
---@param isPlaying boolean
---@param inTransition boolean
---@return boolean
function is_player_active(player, isPlaying, inTransition)
    if player == -1 or
    not NETWORK.NETWORK_IS_PLAYER_ACTIVE(player) then
        return false
    end
    if isPlaying and not PLAYER.IS_PLAYER_PLAYING(player) then
        return false
    end
    if inTransition and
    read_global.int(2657971 + 1 + (player * 465)) ~= 4 then -- Global_2657971[PLAYER::PLAYER_ID() /*465*/]
        return false
    end
    return true
end


--------------------------
-- CAM
--------------------------

---@param dist number
---@return v3
function get_offset_from_cam(dist)
    local rot = CAM.GET_FINAL_RENDERED_CAM_ROT(2)
    local pos = CAM.GET_FINAL_RENDERED_CAM_COORD()
    local dir = rot:toDir()
    dir:mul(dist)
    local offset = v3.new(pos)
    offset:add(dir)
    return offset
end

--------------------------
-- RAYCAST
--------------------------

local TraceFlag =
{
    everything = 4294967295,
    none = 0,
    world = 1,
    vehicles = 2,
    pedsSimpleCollision = 4,
    peds = 8,
    objects = 16,
    water = 32,
    foliage = 256,
}

---@class RaycastResult
---@field didHit boolean
---@field endCoords v3
---@field surfaceNormal v3
---@field hitEntity Entity

---@param dist number
---@param flag? integer
---@return RaycastResult
function get_raycast_result(dist, flag)
    local result = {}
    flag = flag or TraceFlag.everything
    local didHit = memory.alloc(1)
    local endCoords = v3.new()
    local normal = v3.new()
    local hitEntity = memory.alloc_int()
    local camPos = CAM.GET_FINAL_RENDERED_CAM_COORD()
    local offset = get_offset_from_cam(dist)

    local handle = SHAPETEST.START_EXPENSIVE_SYNCHRONOUS_SHAPE_TEST_LOS_PROBE(
        camPos.x, camPos.y, camPos.z,
        offset.x, offset.y, offset.z,
        flag,
        players.user_ped(), 7
    )
    SHAPETEST.GET_SHAPE_TEST_RESULT(handle, didHit, endCoords, normal, hitEntity)

    result.didHit = memory.read_byte(didHit) ~= 0
    result.endCoords = endCoords
    result.surfaceNormal = normal
    result.hitEntity = memory.read_int(hitEntity)
    return result
end

--------------------------
-- STREAMING
--------------------------

---@param model integer
function request_model(model)
    STREAMING.REQUEST_MODEL(model)
    while not STREAMING.HAS_MODEL_LOADED(model) do util.yield_once() end
end


---@param asset string
function request_fx_asset(asset)
    STREAMING.REQUEST_NAMED_PTFX_ASSET(asset)
    while not STREAMING.HAS_NAMED_PTFX_ASSET_LOADED(asset) do util.yield_once() end
end


---@param hash integer
function request_weapon_asset(hash)
    WEAPON.REQUEST_WEAPON_ASSET(hash, 31, 0)
    while not WEAPON.HAS_WEAPON_ASSET_LOADED(hash) do util.yield_once() end
end


---Credits to aaron
---@param textureDict string
function request_streamed_texture_dict(textureDict)
    util.spoof_script("main_persistent", function()
        GRAPHICS.REQUEST_STREAMED_TEXTURE_DICT(textureDict, false)
    end)
end


---@param textureDict string
function set_streamed_texture_dict_as_no_longer_needed(textureDict)
    util.spoof_script("main_persistent", function()
        GRAPHICS.SET_STREAMED_TEXTURE_DICT_AS_NO_LONGER_NEEDED(textureDict)
    end)
end


---@param name string
---@return integer
function request_scaleform_movie(name)
    local handle
    util.spoof_script("main_persistent", function ()
        handle = GRAPHICS.REQUEST_SCALEFORM_MOVIE(name)
    end)
    return handle
end


---@param handle integer
function set_scaleform_movie_as_no_longer_needed(handle)
    util.spoof_script("main_persistent", function ()
        local ptr = memory.alloc_int()
        memory.write_int(ptr, handle)
        GRAPHICS.SET_SCALEFORM_MOVIE_AS_NO_LONGER_NEEDED(ptr)
    end)
end

--------------------------
-- MEMORY
--------------------------

---@param addr integer
---@param offsets integer[]
---@return integer
function addr_from_pointer_chain(addr, offsets)
    if addr == 0 then return 0 end
    for k = 1, (#offsets - 1) do
        addr = memory.read_long(addr + offsets[k])
        if addr == 0 then return 0 end
    end
    addr = addr + offsets[#offsets]
    return addr
end

local HudTimer = {}

HudTimer.SetHeightMultThisFrame = function (mult)
    write_global.int(1655472 + 1163, mult)
end

HudTimer.DisableThisFrame = function()
    write_global.int(2696211, 1)
end


function EnableOTR()
    local toggle_addr = 2657589 + ((PLAYER.PLAYER_ID() * 466) + 1) + 210
    if read_global.int(toggle_addr) == 1 then
        return
    end
    write_global.int(toggle_addr, 1)
    write_global.int(2672505 + 56, NETWORK.GET_NETWORK_TIME() + 1)
end

function DisableOTR()
    write_global.int(2657589 + ((PLAYER.PLAYER_ID() * 466) + 1) + 210, 0)
end

function DisablePhone()
    write_global.int(20366, 1)
end


function is_phone_open()
    if SCRIPT.GET_NUMBER_OF_THREADS_RUNNING_THE_SCRIPT_WITH_THIS_HASH(util.joaat("cellphone_flashhand")) > 0 then
        return true
    end
    return false
end


---@param name string
---@param pattern string
---@param callback fun(address: integer)
function memory_scan(name, pattern, callback)
    local address = memory.scan(pattern)

    if address == NULL then error("Failed to find " .. name) end

    callback(address)
    util.log("Found %s", name)
end

--------------------------
-- TABLE
--------------------------

---Returns a random value from the given table.
---@param t table
---@return any
function table.random(t)
    if rawget(t, 1) ~= nil then
        return t[ math.random(#t) ]
    end
    local list = {}
    for _, value in pairs(t) do
        table.insert(list, value)
    end
    local result = list[math.random(#list)]
    return type(result) ~= "table" and result or table.random(result)
end


function pairs_by_keys(t, f)
    local a = {}
    for n in pairs(t) do table.insert(a, n) end
    table.sort(a, f)
    local i = 0
    local iter = function()
        i = i + 1
        if a[i] == nil then return nil
        else return a[i], t[a[i]]
        end
    end
    return iter
end


---Inserts `value` if `t` does not already includes it.
---@param t table
---@param value any
function table.insert_once(t, value)
    if not table.find(t, value) then table.insert(t, value) end
end


---@generic T: table, K, V
---@param t T
---@param f fun(key: K, value: V): boolean
---@return V
---@nodiscard
function table.find_if(t, f)
    for k, v in pairs(t) do
        if f(k, v) then return k end
    end
    return nil
end


---@generic T: table, K, V
---@param t T
---@param value any
---@return K?
---@nodiscard
function table.find(t, value)
    for k, v in pairs(t) do
        if value == v then return k end
    end
    return nil
end


---@generic T: table, K, V
---@param t T
---@param f fun(key: K, value: V):boolean
---@return integer
function table.count_if(t, f)
    local count = 0
    for k, v in pairs(t) do
        if f(k, v) then count = count + 1 end
    end
    return count
end

--------------------------
-- MISC
--------------------------

---Credits to Sainan
function int_to_uint(int)
    if int >= 0 then return int end
    return (1 << 32) + int
end


function interpolate(y0, y1, perc)
    perc = perc > 1.0 and 1.0 or perc
    return (1 - perc) * y0 + perc * y1
end


---@param num number
---@param places? integer
---@return number?
function round(num, places)
    return tonumber(string.format('%.' .. (places or 0) .. 'f', num))
end


---@param blip integer
---@return v3?
function get_blip_coords(blip)
    if blip == 0 then
        return nil
    end
    local pos = HUD.GET_BLIP_COORDS(blip)
    local tick = 0
    local success, groundz = util.get_ground_z(pos.x, pos.y)
    while not success and tick < 10 do
        util.yield_once()
        success, groundz = util.get_ground_z(pos.x, pos.y)
        tick = tick + 1
    end
    if success then pos.z = groundz end
    return pos
end


---@param pos v3
---@return number?
function get_ground_z(pos)
    local pGroundZ = memory.alloc(4)
    MISC.GET_GROUND_Z_FOR_3D_COORD(pos.x, pos.y, pos.z, pGroundZ, false, true)
    local groundz = memory.read_float(pGroundZ)
    return groundz
end


---@param windowName string #Must be a label
---@param maxInput integer
---@param defaultText string
---@return string
function get_input_from_screen_keyboard(windowName, maxInput, defaultText)
    MISC.DISPLAY_ONSCREEN_KEYBOARD(0, windowName, "", defaultText, "", "", "", maxInput);
    while MISC.UPDATE_ONSCREEN_KEYBOARD() == 0 do
        util.yield_once()
    end
    if MISC.UPDATE_ONSCREEN_KEYBOARD() == 1 then
        return MISC.GET_ONSCREEN_KEYBOARD_RESULT()
    end
    return ""
end


---@param s string
---@param x number
---@param y number
---@param scale number
---@param font integer
function draw_string(s, x, y, scale, font)
    HUD.BEGIN_TEXT_COMMAND_DISPLAY_TEXT("STRING")
    HUD.SET_TEXT_FONT(font or 0)
    HUD.SET_TEXT_SCALE(scale, scale)
    HUD.SET_TEXT_DROP_SHADOW()
    HUD.SET_TEXT_WRAP(0.0, 1.0)
    HUD.SET_TEXT_DROPSHADOW(1, 0, 0, 0, 0)
    HUD.SET_TEXT_OUTLINE()
    HUD.SET_TEXT_EDGE(1, 0, 0, 0, 0)
    HUD.ADD_TEXT_COMPONENT_SUBSTRING_PLAYER_NAME(s)
    HUD.END_TEXT_COMMAND_DISPLAY_TEXT(x, y, 0)
end

--------------------------
-- BITFIELD
--------------------------

---@class Bitwise
---@field bits integer
local Bitfield = {}
Bitfield.__index = Bitfield

function Bitfield.new()
    return setmetatable({bits = 0}, Bitfield)
end

---@param place integer
---@return boolean
function Bitfield:IsBitSet(place)
    return self.bits & (1 << place) ~= 0
end

---@param place integer
function Bitfield:SetBit(place)
    self.bits = self.bits | (1 << place)
end

---@param place integer
function Bitfield:ClearBit(place)
    self.bits = self.bits & ~(1 << place)
end

---@param place integer
---@param on boolean
function Bitfield:ToggleBit(place, on)
    if on then self:SetBit(place) else self:ClearBit(place) end
end

function Bitfield:reset()
    self.bits = 0
end

Bitfield.__tostring = function(self)
    local tbl = {}
    local num = self.bits
    for b = 32, 1, -1 do
        tbl[b] = math.fmod(num, 2)
        num = math.floor((num - tbl[b]) / 2)
    end
    return table.concat(tbl)
end

--------------------------

local self = {}
local version = 29.51
local State <const> =
{
    GettingNearbyEnts = 0,
    SettingTargets = 1,
    Reseted = 2
}
local state = State.Reseted
local targetEnts = {-1, -1, -1, -1, -1, -1}
---Stores nearby targetable entities
---@type integer[]
local nearbyEntities = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
local numTargets = 0
local maxTargets = 1
local lastShot <const> = newTimer()
local rechargeTimer <const> = newTimer()
local entCount = 0
local shotCount = 0
local numShotTargets = 0 -- the number of targets we've shot
local chargeLevel = 100.0
local vehicleWeaponSide = 0
local myVehicle = 0
local weapon <const> = util.joaat("VEHICLE_WEAPON_SPACE_ROCKET")
local lockOnBits <const> = Bitfield.new()
local bits <const> = Bitfield.new()
local whiteList <const> = Bitfield.new()

local NULL <const> = 0
---@type Timer[]
local homingTimers <const> = {}
---@type Sound[]
local amberHomingSounds <const> = {}
---@type Sound[]
local redHomingSounds <const> = {}
---@type Timer[]
local lostTargetTimers <const> = {}

for i = 1, 6 do
    homingTimers[i] = newTimer()
    lostTargetTimers[i] = newTimer()
    amberHomingSounds[i] = Sound.new("VULKAN_LOCK_ON_AMBER", NULL)
    redHomingSounds[i] = Sound.new("VULKAN_LOCK_ON_RED", NULL)
end

local Bit_IsTargetShooting <const> = 0
local Bit_IsRecharging <const> = 1
local Bit_IsCamPointingInFront <const> = 2

local Bit_IgnoreFriends <const> = 0
local Bit_IgnoreOrgMembers <const> = 1
local Bit_IgnoreCrewMembers <const> = 2

whiteList:SetBit(Bit_IgnoreFriends)

---@param position v3
---@param scale number
---@param colour Colour
local DrawLockonSprite = function (position, scale, colour)
    if GRAPHICS.HAS_STREAMED_TEXTURE_DICT_LOADED("mpsubmarine_periscope") then
        local txdSizeX = scale * 0.042
        local txdSizeY = scale * 0.042 * GRAPHICS.GET_ASPECT_RATIO(false)
        GRAPHICS.SET_DRAW_ORIGIN(position.x, position.y, position.z, 0)
        GRAPHICS.DRAW_SPRITE(
            "mpsubmarine_periscope", "target_default", 0.0, 0.0, txdSizeX, txdSizeY, 0.0, colour.r, colour.g, colour.b, colour.a, true, 0)
        GRAPHICS.CLEAR_DRAW_ORIGIN()
    end
end


---@param vehicle Vehicle
---@return boolean
local IsAnyPoliceVehicle = function(vehicle)
    local modelHash = ENTITY.GET_ENTITY_MODEL(vehicle)
    switch int_to_uint(modelHash)do
        case 0x79FBB0C5:
        case 0x9F05F101:
        case 0x71FA16EA:
        case 0x8A63C7B9:
        case 0x1517D4D9:
        case 0xFDEFAEC3:
        case 0x1B38E955:
        case 0x95F4C618:
        case 0xA46462F7:
        case 0x9BAA707C:
        case 0x72935408:
        case 0xB822A1AA:
        case 0xE2E7D4AB:
        case 0x9DC66994:
            return true
    end
    return false
end


---@param entity Entity
---@return boolean
local IsEntityInSafeScreenPos = function (entity)
    local pScreenX = memory.alloc(4)
    local pScreenY = memory.alloc(4)
    local pos = ENTITY.GET_ENTITY_COORDS(entity, true)
    if not GRAPHICS.GET_SCREEN_COORD_FROM_WORLD_COORD(pos.x, pos.y, pos.z, pScreenX, pScreenY) then
        return false
    end
    local screenX = memory.read_float(pScreenX)
    local screenY = memory.read_float(pScreenY)
    if screenX < 0.1 or screenX > 0.9 or screenY < 0.1 or screenY > 0.9 then
        return false
    end
    return true
end


---@param player Player
---@return integer
local GetPlayerOrgBoss = function (player)
    if player ~= -1 then
        return players.get_boss(player)
    end
    return -1
end


---@param player Player
---@param target Player
---@return boolean
local ArePlayersInTheSameOrg = function (player, target)
    local boss = GetPlayerOrgBoss(player)
    return boss ~= -1 and boss == GetPlayerOrgBoss(target)
end


---@param player Player
---@return integer
local GetHandleFromPlayer = function (player)
    local handle = memory.alloc(104)
    NETWORK.NETWORK_HANDLE_FROM_PLAYER(player, handle, 13)
    return handle
end


---@param player Player
---@param target Player
---@return boolean
local ArePlayersInTheSameCrew = function (player, target)
    if NETWORK.NETWORK_CLAN_SERVICE_IS_VALID() then
        local targetHandle = GetHandleFromPlayer(target)
        local handle = GetHandleFromPlayer(player)

        if NETWORK.NETWORK_CLAN_PLAYER_IS_ACTIVE(handle) and NETWORK.NETWORK_CLAN_PLAYER_IS_ACTIVE(targetHandle) then
            local targetClanDesc = memory.alloc(280)
            local clanDesc = memory.alloc(280)

            NETWORK.NETWORK_CLAN_PLAYER_GET_DESC(clanDesc, 35, handle)
            NETWORK.NETWORK_CLAN_PLAYER_GET_DESC(targetClanDesc, 35, targetHandle)
            return memory.read_int(clanDesc + 0x0) == memory.read_int(targetClanDesc + 0x0)
        end
    end
    return false
end


---@param ped Ped
local IsPedAnyTargetablePlayer = function (ped)
    local player = NETWORK.NETWORK_GET_PLAYER_INDEX_FROM_PED(ped)
    if not is_player_active(player, true, true) then
        return false
    end

    if is_player_in_interior(player) or is_player_passive(player) or
    NETWORK.IS_ENTITY_A_GHOST(ped) then
        return false
    elseif whiteList:IsBitSet(Bit_IgnoreFriends) and is_player_friend(player) then
        return false
    elseif whiteList:IsBitSet(Bit_IgnoreOrgMembers) and
    ArePlayersInTheSameOrg(players.user(), player) then
        return false
    elseif whiteList:IsBitSet(Bit_IgnoreCrewMembers) and
    ArePlayersInTheSameCrew(players.user(), player) then
        return false
    end
    return true
end


---@param vehicle Vehicle
---@return boolean
local DoesVehicleHavePlayerDriver = function(vehicle)
    if VEHICLE.IS_VEHICLE_SEAT_FREE(vehicle, -1, false) then
        return false
    end
    local driver = VEHICLE.GET_PED_IN_VEHICLE_SEAT(vehicle, -1, false)
    if not ENTITY.DOES_ENTITY_EXIST(driver) or not PED.IS_PED_A_PLAYER(driver) or
    not IsPedAnyTargetablePlayer(driver) then
        return false
    end
    return true
end


---@param player Player
---@return integer
local GetPlayerWantedLevel = function (player)
    return PLAYER.GET_PLAYER_WANTED_LEVEL(player)
end


---@param entity Entity
---@return boolean
local IsEntityTargetable = function(entity)
    if not ENTITY.DOES_ENTITY_EXIST(entity) or ENTITY.IS_ENTITY_DEAD(entity, false) then
        return false
    end
    local distance = get_distance_between_entities(myVehicle, entity)
    if distance > 500.0 or distance < 10.0 then
        return false
    end
    if ENTITY.IS_ENTITY_A_PED(entity) and PED.IS_PED_A_PLAYER(entity) and
    players.user_ped() ~= entity and not PED.IS_PED_IN_ANY_VEHICLE(entity, false) and
    IsPedAnyTargetablePlayer(entity) then
        return true
    elseif ENTITY.IS_ENTITY_A_VEHICLE(entity) and entity ~= myVehicle then
        if DoesVehicleHavePlayerDriver(entity) then
            return true
        elseif GetPlayerWantedLevel(players.user()) > 0 and IsAnyPoliceVehicle(entity) then
            return true
        end
    end
    return false
end


local SetNearbyEntities = function()
    local count = 1
    local entities = entities.get_all_vehicles_as_handles()
    for _, player in ipairs(players.list(false)) do
        entities[#entities+1] = PLAYER.GET_PLAYER_PED_SCRIPT_INDEX(player)
    end
    for _, entity in ipairs(entities) do
        if count == 20 then break end
        if bits:IsBitSet(Bit_IsCamPointingInFront) and IsEntityTargetable(entity) and
        not table.find(targetEnts, entity) and not table.find(nearbyEntities, entity) and
        IsEntityInSafeScreenPos(entity) then
            nearbyEntities[count] = entity
            count = count + 1
        end
    end
    state = State.SettingTargets
end


---@param entity Entity
---@return boolean
local TargetEntitiesInsert = function (entity)
    for i, target in ipairs(targetEnts) do
        if target == -1 or not ENTITY.DOES_ENTITY_EXIST(target) then
            targetEnts[i] = entity
            numTargets = numTargets + 1
            return true
        end
    end
    return false
end


---@return integer
local GetFartherTargetIndex = function()
    local lastDistance = 0.0
    local index = -1
    local myPos = ENTITY.GET_ENTITY_COORDS(players.user_ped(), true)
    for i = 1, maxTargets do
        local pos = ENTITY.GET_ENTITY_COORDS(targetEnts[i], true)
        local distance = myPos:distance(pos)
        if distance > lastDistance then
            index = i
            lastDistance = distance
        end
    end
    return index
end


---@param entity Entity
---@param amplitude number
---@return boolean
local IsCameraPointingInFrontOfEntity = function(entity, amplitude)
    local camDir = CAM.GET_GAMEPLAY_CAM_ROT(0):toDir()
    local fwdVector = ENTITY.GET_ENTITY_FORWARD_VECTOR(entity)
    camDir.z, fwdVector.z = 0.0, 0.0
    local angle = math.acos(fwdVector:dot(camDir) / (#camDir * #fwdVector))
    return math.deg(angle) < amplitude
end


local SetTargetEntities = function()
    if entCount < 0 or entCount > 19 then
        entCount = 0
    end
    local entity = nearbyEntities[entCount + 1]

    if ENTITY.DOES_ENTITY_EXIST(entity) and not ENTITY.IS_ENTITY_DEAD(entity, false) and
    ENTITY.HAS_ENTITY_CLEAR_LOS_TO_ENTITY(myVehicle, entity, 287) then
        if numTargets < maxTargets then
            if TargetEntitiesInsert(entity) then
                nearbyEntities[entCount + 1] = -1
                entCount = entCount + 1
            end
        else
            local targetId = GetFartherTargetIndex()
            local target = targetEnts[targetId]

            if targetId >= 1 and target then
                local entityPos = ENTITY.GET_ENTITY_COORDS(entity, true)
                local myPos = ENTITY.GET_ENTITY_COORDS(players.user_ped(), true)
                local targetPos = ENTITY.GET_ENTITY_COORDS(target, true)
                local targetDist = targetPos:distance(myPos)
                local entDist = entityPos:distance(myPos)
                if targetDist > entDist then targetEnts[targetId] = entity end
            end

            nearbyEntities[entCount + 1] = -1
            entCount = entCount + 1
        end
    else
        nearbyEntities[entCount + 1] = -1
        entCount = entCount + 1
    end

    if entCount > 19 then
        state = State.GettingNearbyEnts
        entCount = 0
    end
end


local IsAnyHomingSoundActive = function()
    for i = 1, 6 do
        local amberSound = amberHomingSounds[i]
        local redSound = redHomingSounds[i]
        if not amberSound:hasFinished() or not redSound:hasFinished() then
            return true
        end
    end
    return false
end


local IsWebBrowserOpen = function ()
    return SCRIPT.GET_NUMBER_OF_THREADS_RUNNING_THE_SCRIPT_WITH_THIS_HASH(util.joaat("appinternet")) > 0
end

local IsCameraAppOpen = function ()
    return SCRIPT.GET_NUMBER_OF_THREADS_RUNNING_THE_SCRIPT_WITH_THIS_HASH(util.joaat("appcamera")) > 0
end


---@param entity Entity
---@param count integer
local LockonEntity = function (entity, count)
    local redSound = redHomingSounds[count]
    local bitPlace = count - 1
    local lockOnTimer = homingTimers[count]
    local amberSound = amberHomingSounds[count]

    if not ENTITY.DOES_ENTITY_EXIST(entity) or ENTITY.IS_ENTITY_DEAD(entity, false) or
    not IsEntityInSafeScreenPos(entity) or (IsWebBrowserOpen() or IsCameraAppOpen()) then
        amberSound:stop()
        lockOnBits:ClearBit(bitPlace)
        redSound:stop()
        lockOnBits:ClearBit(bitPlace + 6)
        return
    end

    if ENTITY.IS_ENTITY_A_VEHICLE(entity) and VEHICLE.IS_VEHICLE_DRIVEABLE(entity, false) then
        local driver = VEHICLE.GET_PED_IN_VEHICLE_SEAT(entity, -1, false)
        if ENTITY.DOES_ENTITY_EXIST(driver) and PED.IS_PED_A_PLAYER(driver) and
        is_player_active(NETWORK.NETWORK_GET_PLAYER_INDEX_FROM_PED(driver), true, true) then
            VEHICLE.SET_VEHICLE_HOMING_LOCKEDONTO_STATE(entity, 2)
        end
    end

    if not lockOnBits:IsBitSet(bitPlace) then
        if amberSound:hasFinished() and not IsAnyHomingSoundActive() then
            lockOnBits:SetBit(bitPlace)
            amberSound:play()
            lockOnTimer.reset()
        end
    elseif not lockOnBits:IsBitSet(bitPlace + 6) and
    lockOnTimer.elapsed() >= 1000 then
        amberSound:stop()
        if redSound:hasFinished() then
            lockOnBits:SetBit(bitPlace + 6)
            redSound:play()
            lockOnTimer.reset()
        end
    elseif lockOnBits:IsBitSet(bitPlace + 6) and
    lockOnTimer.elapsed() >= 700 then
        if not redSound:hasFinished() then redSound:stop() end
    end

    local hudColour = HudColour.orange
    if lockOnBits:IsBitSet(bitPlace + 6) then
        hudColour = HudColour.red
    end
    local pos = ENTITY.GET_ENTITY_COORDS(entity, true)
    DrawLockonSprite(pos, 1.0, get_hud_colour(hudColour))
end


local GetCrosshairPosition = function ()
    local vehPos = ENTITY.GET_ENTITY_COORDS(myVehicle, true)
    local vehDir = ENTITY.GET_ENTITY_ROTATION(myVehicle, 2):toDir()
    local frontPos = v3.new(vehDir)
    frontPos:mul(100)
    frontPos:add(vehPos)

    local handle =
    SHAPETEST.START_EXPENSIVE_SYNCHRONOUS_SHAPE_TEST_LOS_PROBE(
        vehPos.x, vehPos.y, vehPos.z,
        frontPos.x, frontPos.y, frontPos.z, 511,
        myVehicle, 7
    )

    local pHit = memory.alloc(1)
    local endCoords = v3.new()
    local normal = v3.new()
    local pHitEntity = memory.alloc_int()
    SHAPETEST.GET_SHAPE_TEST_RESULT(handle, pHit, endCoords, normal, pHitEntity)
    return memory.read_int(pHit) == 1 and endCoords or frontPos
end


local LockonTargets = function()
    if numTargets == 0 and not (IsWebBrowserOpen() or IsCameraAppOpen()) then
        local pos = GetCrosshairPosition()
        local colour = get_hud_colour(HudColour.white)
        colour.a = 160
        DrawLockonSprite(pos, 1.0, colour)
    end
    for i, target in ipairs(targetEnts) do LockonEntity(target, i) end
end


local UpdateTargetEntities = function ()
    local count = 0
    for i = 1, 6 do
        if ENTITY.DOES_ENTITY_EXIST(targetEnts[i]) then
            local timer = lostTargetTimers[i]
            local entity = targetEnts[i]

            if i > maxTargets then
                targetEnts[i] = -1
                numTargets = numTargets - 1
                timer.disable()

            elseif not IsEntityInSafeScreenPos(entity) or not IsEntityTargetable(entity) or
            not bits:IsBitSet(Bit_IsCamPointingInFront) then
                targetEnts[i] = -1
                numTargets = numTargets - 1
                timer.disable()

            elseif not ENTITY.HAS_ENTITY_CLEAR_LOS_TO_ENTITY(myVehicle, entity, 287) then
                if not timer.isEnabled() then
                    timer.reset()
                elseif timer.elapsed() > 1000 then
                    targetEnts[i] = -1
                    numTargets = numTargets - 1
                    timer.disable()
                end

            else timer.disable() end
        end

        if ENTITY.DOES_ENTITY_EXIST(targetEnts[i]) then
            count = count + 1
        end
    end

    if count ~= numTargets then
        numTargets = count
    end
end


---@param vehicle Vehicle
---@param damage integer
---@param weaponHash Hash
---@param ownerPed Ped
---@param isAudible boolean
---@param isVisible boolean
---@param speed number
---@param target Ped
---@param position integer #right: 0, left: 1
local ShootFromVehicle = function (vehicle, damage, weaponHash, ownerPed, isAudible, isVisible, speed, target, position)
    local pos = ENTITY.GET_ENTITY_COORDS(vehicle, true)
    local hash = ENTITY.GET_ENTITY_MODEL(vehicle)
    local min, max = v3.new(), v3.new()
    MISC.GET_MODEL_DIMENSIONS(hash, min, max)
    local direction = ENTITY.GET_ENTITY_ROTATION(vehicle, 2):toDir()
    local a
    local is_heli = VEHICLE.IS_THIS_MODEL_A_HELI(hash)

    if position == 0 then
        if not is_heli then
            local offset = v3.new(min.x + 0.3, max.y - 0.15, 0.3)
            a = ENTITY.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS(vehicle, offset.x, offset.y, offset.z)
        else
            local offset = v3.new(min.x + 5, max.y - 0.15, 0.3)
            a = ENTITY.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS(vehicle, offset.x, offset.y, offset.z)
        end
    elseif position == 1 then
        if not is_heli then
            local offset = v3.new(max.x - 0.3, max.y - 0.15, 0.3)
            a = ENTITY.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS(vehicle, offset.x, offset.y, offset.z)
        else
            local offset = v3.new(max.x - 5, max.y - 0.15, 0.3)
            a = ENTITY.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS(vehicle, offset.x, offset.y, offset.z)
        end
    else
        error("got unexpected position")
    end

    local b = v3.new(direction)
    b:mul(5.0); b:add(a)
    MISC.SHOOT_SINGLE_BULLET_BETWEEN_COORDS_IGNORE_ENTITY_NEW(
        a.x, a.y, a.z,
        b.x, b.y, b.z,
        damage,
        true,
        weaponHash,
        ownerPed,
        isAudible,
        not isVisible,
        speed,
        vehicle,
        false, false, target, false, 0, 0, 0
    )
    AUDIO.PLAY_SOUND_FROM_COORD(-1, "Fire", pos.x, pos.y, pos.z, "DLC_BTL_Terrobyte_Turret_Sounds", true, 200, true)
end


local ShootMissiles = function()
    local controlId = 68
    if PED.IS_PED_IN_FLYING_VEHICLE(players.user_ped()) then
        controlId = 114
    end
    local target = 0

    if (PAD.IS_DISABLED_CONTROL_PRESSED(2, controlId) or bits:IsBitSet(Bit_IsTargetShooting)) and
    not bits:IsBitSet(Bit_IsRecharging) and lastShot.elapsed() > 300 then
        if shotCount < 0 or shotCount > 5 then
            shotCount = 0
        end

        vehicleWeaponSide = vehicleWeaponSide == 0 and 1 or 0
        local ownerPed = players.user_ped()

        if numTargets > 0 then
            if ENTITY.DOES_ENTITY_EXIST(targetEnts[numShotTargets + 1]) and
            not ENTITY.IS_ENTITY_DEAD(targetEnts[numShotTargets + 1], false) then
                target = targetEnts[numShotTargets + 1]
                bits:SetBit(Bit_IsTargetShooting)
                ShootFromVehicle(myVehicle, 200, weapon, ownerPed, true, true, 1000.0, target, vehicleWeaponSide)
                shotCount = shotCount + 1
                numShotTargets = numShotTargets + 1
                lastShot.reset()
            end

            if numTargets == numShotTargets then
                bits:SetBit(Bit_IsRecharging)
                bits:ClearBit(Bit_IsTargetShooting)
                numShotTargets = 0
                shotCount = 0
                chargeLevel = 0
                rechargeTimer.reset()
            end

        else
            ShootFromVehicle(myVehicle, 200, weapon, ownerPed, true, true, 1000.0, 0, vehicleWeaponSide)
            shotCount = shotCount + 1
            lastShot.reset()
            if shotCount == 6 then
                bits:SetBit(Bit_IsRecharging)
                chargeLevel = 0
                shotCount = 0
                rechargeTimer.reset()
            end
        end
    end
end


local StopHomingSounds = function()
    for i = 1, 6 do
        if not redHomingSounds[i]:hasFinished() then
            redHomingSounds[i]:stop()
        end
        if not amberHomingSounds[i]:hasFinished() then
            amberHomingSounds[i]:stop()
        end
    end
end


local LockonManager = function ()
    if bits:IsBitSet(Bit_IsRecharging) then
        if rechargeTimer.elapsed() < 3000 then
            chargeLevel = 100 * rechargeTimer.elapsed() / 3000
            StopHomingSounds()
            lockOnBits:reset()
            return
        else
            bits:ClearBit(Bit_IsRecharging)
            chargeLevel = 100.0
            shotCount = 0
            numShotTargets = 0
        end
    end

    if not bits:IsBitSet(Bit_IsTargetShooting) and not bits:IsBitSet(Bit_IsRecharging) and
    not (IsWebBrowserOpen() or IsCameraAppOpen()) then
        if state == State.GettingNearbyEnts then
            SetNearbyEntities()
        elseif state == State.SettingTargets then
            SetTargetEntities()
        end
        UpdateTargetEntities()
    end
    LockonTargets()
end


Print = {}

---@param font integer
---@param scale v3
---@param centred boolean
---@param rightJustified boolean
---@param outline boolean
---@param colour? Colour
---@param wrap? v3
Print.setupdraw = function(font, scale, centred, rightJustified, outline, colour, wrap)
    HUD.SET_TEXT_FONT(font)
    HUD.SET_TEXT_SCALE(scale.x, scale.y)
    colour = colour or {r = 255, g = 255, b = 255, a = 255}
    HUD.SET_TEXT_COLOUR(colour.r, colour.g, colour.b, colour.a)
    wrap = wrap or {x = 0.0, y = 1.0}
    HUD.SET_TEXT_WRAP(wrap.x, wrap.y)
    HUD.SET_TEXT_RIGHT_JUSTIFY(rightJustified)
    HUD.SET_TEXT_CENTRE(centred)
    HUD.SET_TEXT_DROPSHADOW(0, 0, 0, 0, 0)
    HUD.SET_TEXT_EDGE(0, 0, 0, 0, 0)
    if outline then HUD.SET_TEXT_OUTLINE() end
end


---@param text string
---@param x number
---@param y number
Print.drawstring = function (text, x, y)
    HUD.BEGIN_TEXT_COMMAND_DISPLAY_TEXT(text)
    GRAPHICS.BEGIN_TEXT_COMMAND_SCALEFORM_STRING(text)
    GRAPHICS.END_TEXT_COMMAND_SCALEFORM_STRING()
    HUD.END_TEXT_COMMAND_DISPLAY_TEXT(x, y, 0)
end


local DrawChargingMeter = function ()
    if not is_phone_open() then
        local maxWidth <const> = 0.119
        local posY <const> = 0.63

        local colour = {r = 0, g = 153, b = 51, a = 255}
        if chargeLevel < 100 then
            colour = {r = 153, g = 0, b = 0, a = 255}
        end
        local width = interpolate(0.0, maxWidth, chargeLevel / 100)
        local height <const> = 0.035
        local rectPosX = 0.85 + width/2
        GRAPHICS.DRAW_RECT(rectPosX, posY, width, height, colour.r, colour.g, colour.b, colour.a, true)

        local textColour = get_hud_colour(HudColour.white)
        Print.setupdraw(4, {x = 0.55, y = 0.55}, true, false, false, textColour)
        local textPosX = 0.85 + maxWidth/2
        local text = (chargeLevel == 100) and "DRONE_READY" or "DRONE_CHARGING"
        Print.drawstring(text, textPosX, posY - 0.019)

        --Caption
        local captionHeight <const> = 0.06
        GRAPHICS.DRAW_RECT(0.85 + maxWidth/2, posY - captionHeight + 0.005, maxWidth, captionHeight, 156, 156, 156, 80, true)
        Print.setupdraw(4, {x = 0.65, y = 0.65}, true, false, false, textColour)
        Print.drawstring("DRONE_MISSILE", textPosX + 0.001, posY - captionHeight - 0.015)
    end
end


local DisableControlActions = function ()
    PAD.DISABLE_CONTROL_ACTION(2, 25, true)
    PAD.DISABLE_CONTROL_ACTION(2, 91, true)
    PAD.DISABLE_CONTROL_ACTION(2, 99, true)
    PAD.DISABLE_CONTROL_ACTION(2, 115, true)
    PAD.DISABLE_CONTROL_ACTION(2, 262, true)
    PAD.DISABLE_CONTROL_ACTION(2, 68, true)
    PAD.DISABLE_CONTROL_ACTION(2, 69, true)
    PAD.DISABLE_CONTROL_ACTION(2, 70, true)
    PAD.DISABLE_CONTROL_ACTION(2, 114, true)
    PAD.DISABLE_CONTROL_ACTION(2, 331, true)
end


self.reset = function()
    set_streamed_texture_dict_as_no_longer_needed("mpsubmarine_periscope")
    lockOnBits:reset()
    bits:reset()
    targetEnts = {-1, -1, -1, -1, -1, -1}
    entCount = 0
    numTargets = 0
    shotCount = 0
    numShotTargets = 0
    chargeLevel = 100.0
    myVehicle = 0
    StopHomingSounds()
    nearbyEntities = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}
    for i = 1, 6 do lostTargetTimers[i].disable() end
    state = State.Reseted
end


---@param ignore boolean
self.SetIgnoreFriends = function(ignore)
    whiteList:ToggleBit(Bit_IgnoreFriends, ignore)
end

---@param ignore boolean
self.SetIgnoreOrgMembers = function (ignore)
    whiteList:ToggleBit(Bit_IgnoreOrgMembers, ignore)
end

---@param ignore boolean
self.SetIgnoreCrewMembers = function (ignore)
    whiteList:ToggleBit(Bit_IgnoreCrewMembers, ignore)
end

---@param value integer
self.SetMaxTargets = function (value)
    maxTargets = value
end

self.getVersion = function ()
    return version
end


self.mainLoop = function (draw_charge_meter=false)
    if is_player_active(players.user(), true, true) and PED.IS_PED_IN_ANY_VEHICLE(players.user_ped(), false) then
        local vehicle = PED.GET_VEHICLE_PED_IS_IN(players.user_ped(), false)
        if ENTITY.DOES_ENTITY_EXIST(vehicle) and not ENTITY.IS_ENTITY_DEAD(vehicle, false) and
        VEHICLE.IS_VEHICLE_DRIVEABLE(vehicle, false) and
        VEHICLE.GET_PED_IN_VEHICLE_SEAT(vehicle, -1, false) == players.user_ped() then

            if not is_player_passive(players.user()) then
                if state == State.Reseted then
                    request_streamed_texture_dict("mpsubmarine_periscope")
                    --This prevents not being able to shoot
                    WEAPON.GIVE_DELAYED_WEAPON_TO_PED(players.user_ped(), weapon, -1, false)
                    state = State.GettingNearbyEnts
                end
                myVehicle = vehicle
                if IsCameraPointingInFrontOfEntity(vehicle, 40.0) then
                    bits:SetBit(Bit_IsCamPointingInFront)
                else
                    bits:ClearBit(Bit_IsCamPointingInFront)
                end

                LockonManager()
                if not (IsWebBrowserOpen() or IsCameraAppOpen()) then
                    ShootMissiles()
                    if draw_charge_meter then DrawChargingMeter() end
                end
                DisableControlActions()

            elseif not is_player_in_any_rc_vehicle(players.user()) then
                if state ~= State.Reseted then
                    self.reset()
                end
                local timerStart = memory.script_global(2738934 + 4515)
                local timerState = memory.script_global(2738934 + 4515 + 1)
                if timerStart ~= NULL and timerState ~= NULL and
                memory.read_int(timerState) == 0 then
                    notification:normal(trans.DisablingPassive)
                    memory.write_int(timerStart, NETWORK.GET_NETWORK_TIME())
                    memory.write_int(timerState, 1)
                end
            end
        elseif state ~= State.Reseted then
            self.reset()
        end
    elseif state ~= State.Reseted then
        self.reset()
    end
end

return self
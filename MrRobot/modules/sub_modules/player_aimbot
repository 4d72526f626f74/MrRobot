local T, S, H = require('translations'), require('shared'), require('handler')
local Bitfield = require('bitfield')

enum FOVTypes begin
    Normal = 1,
    Precision = 2
end

pluto_class PlayerAimbot
    function __construct(root)
        self.root = root:list(T'Player', {T'rplayeraimbot'}, T'Player Aimbot')
        self.targets = pluto_new Bitfield(0)

        self.bone = 31086
        self.use_fov = true
        self.ignore_vehicles = true
        self.target_friends = false
        self.show_target = true
        self.toast_target = true
        self.damage_override = false
        self.chance_based = false
        self.spectate = true

        self.fov = 1
        self.fov_types = {'Normal', 'Precision'}
        self.fov_type = 1
        self.damage = 100
        self.chance = 100

        self.sx_ptr = memory.alloc(4)
        self.sy_ptr = memory.alloc(4)
        self.ent_ptr = memory.alloc(4)

        self:Init()
    end

    function Init()
        self.root:toggle_loop(T'Aimbot', {}, T'Aimbot', || -> self:Aimbot())
        self.root:toggle_loop(T'Unfair Aimbot', {}, T'A very unfair variant of aimbot', || -> self:UnfairAimbot())
        self.root:toggle_loop(T'Trigger Bot', {}, T'Shoots when your crosshair is on an enemy', || -> self:TriggerBot())
        self.root:toggle_loop(T'Unfair Trigger Bot', {}, T'Unfair variant of trigger bot', || -> self:UnfairTriggerBot())
        self.root:divider('')

        self.root:toggle(T'Use FOV', {}, T'Will the aimbot use FOV or just annihilate them regardless of where you aim?', function(state)
            self.use_fov = state
        end, self.use_fov)

        self.root:toggle(T'Ignore Vehicles', {}, T'Will the aimbot ignore vehicles?', function(state)
            self.ignore_vehicles = state
        end, self.ignore_vehicles)

        self.root:toggle(T'Target Friends', {}, T'Will the aimbot target friends?', function(state)
            self.target_friends = state
        end, self.target_friends)

        self.root:toggle(T'Show Target', {}, T'Will the aimbot show the target?', function(state)
            self.show_target = state
        end, self.show_target)

        self.root:toggle(T'Toast Target', {}, T'Will the aimbot toast the target?', function(state)
            self.toast_target = state
        end, self.toast_target)

        self.root:toggle(T'Damage Override', {}, T'Will the aimbot override the damage?', function(state)
            self.damage_override = state
        end, self.damage_override)

        self.root:toggle(T'Chance Based', {}, T'Will the aimbot be chance based?', function(state)
            self.chance_based = state
        end, self.chance_based)

        self.root:toggle(T'Spectate', {}, T'Automatically spectate when outside of a certain range (this only applies to snipers)', function(state)
            self.spectate = state
        end, self.spectate)

        self.root:divider('')
        self.root:list_select(T'Bone', {}, T'Bone to target', {'Head', 'Chest', 'Stomach', 'Left Foot', 'Right Leg', 'Left Hand', 'Right Hand', 'Pelvis', 'Left Leg', 'Left Knee', 'Left Arm'}, 1, function(index)
            self.bone = S.AimbotBones[index] or 31086
        end, self.bone)

        self.root:list_select(T'FOV Type', {}, T'The type of FOV', self.fov_types, 1, function(index)
            self.fov_type = index
            if index == FOVTypes.Normal then
                self.fov = self.normal_fov.value
            else
                self.fov = self.precise_fov.value / 100
            end
        end)

        self.normal_fov = self.root:slider(T'FOV', {T'rpedaimbotfov'}, T'The FOV of the aimbot', 0, 180, self.fov, 1, function(value)
            if self.fov_type == FOVTypes.Normal then
                self.fov = value
            end
        end)

        self.precise_fov = self.root:slider_float(T'Precision FOV', {T'rpedaimbotfovp'}, T'A more precise FOV for the aimbot', 0.0, 180.0 * 100, self.fov * 100, 1.0, function(value)
            if self.fov_type == FOVTypes.Precision then
                self.fov = value / 100
            end
        end)

        self.root:slider(T'Damage', {T'rpedaimbotdamage'}, T'The damage of the aimbot', 0, math.max_int, self.damage, 1, function(value)
            self.damage = value
        end)

        self.root:slider(T'Chance', {T'rpedaimbotchance'}, T'The chance of the aimbot', 0, 100, self.chance, 1, function(value)
            self.chance = value
        end)

        self.root:divider('')
        self.target_list = self.root:list(T'Targets', {}, T'Players that the aimbot will target')
        self:HandleTargetsUpdating()
    end

    function HandleTargetsUpdating()
        H.PlayerAimbotAdd = S:Partial(function(self, pid, root)
            local name = players.get_name(pid)
            local ref = self.target_list:refByRelPath(name)
            if S:PlayerExists(pid) and pid ~= players.user() then
                if not ref:isValid() then
                    if not S:IsFriend(pid) then
                        self.targets:Set(1 << pid)
                    end
                    self.target_list:toggle(name, {}, T'Should this player be targetted by the aimbot?', function(state)
                        self.targets:SetBool(1 << pid, state)
                    end, self.targets:IsSet(1 << pid))
                end
            end
        end, self)

        H.PlayerAimbotRemove = S:Partial(function(self, pid, name)
            self.targets:Clear(1 << pid)
            local ref = self.target_list:refByRelPath(name)
            if ref:isValid() then
                ref:delete()
            end
        end, self)
    end

    function Aimbot()
        if not util.is_session_started() then return end
        local target = self:GetTarget()
        local localplayer = players.localplayer()
        if target ~= nil then
            if self.show_target then
                local coords = ped.get_ped_bone_coords(target.ped, self.bone, 0.0, 0.0, 0.0)
                if graphics.get_screen_coord_from_world_coord(coords.x, coords.y, coords.z, self.sx_ptr, self.sy_ptr) then
                    local sx, sy = memory.read_float(self.sx_ptr), memory.read_float(self.sy_ptr)
                    directx.draw_line(0.5, 0.5, sx, sy, { r=1, g=0, b=0, a=1 })
                end
            end

            if localplayer:is_ped_shooting() and localplayer:has_entity_clear_los_to_entity(target.ped, 17) then
                local weapon_hash = localplayer:get_selected_ped_weapon()
                local damage = self.damage_override ? self.damage : weapon.get_weapon_damage(weapon_hash, self.bone)
                local chance = (self.chance_based) ? math.random(1, 100) : 100

                if chance > self.chance then return end
                if not ped.is_ped_in_any_vehicle(target.ped) then
                    local from = self:GetWeaponBarrelCoords()
                    local to = ped.get_ped_bone_coords(target.ped, self.bone, 0.0, 0.0, 0.0)
                    self:ShootBullet(localplayer.entity, weapon_hash, damage, from, to)
                else
                    local from = ped.get_ped_bone_coords(target.ped, 24816, 0.0, 1.0, 0.2)
                    local to = ped.get_ped_bone_coords(target.ped, self.bone, 0.0, 0.0, 0.0)
                    self:ShootBullet(localplayer.entity, weapon_hash, damage, from, to)
                end
            end
        end
    end

    function UnfairAimbot()
        if not util.is_session_started() then return end
        local target = self:GetClosestPlayer()
        if target ~= nil and self.toast_target then util.toast(players.get_name(target)) end
        if target == nil then return end
        if not self.targets:IsSet(1 << target) then return end

        local pped = player.get_player_ped(target)
        local localplayer = players.localplayer()
        local coords = ped.get_ped_bone_coords(pped, self.bone, 0.0, 0.0, 0.0)
        if self.show_target then
            if graphics.get_screen_coord_from_world_coord(coords.x, coords.y, coords.z, self.sx_ptr, self.sy_ptr) then
                local sx, sy = memory.read_float(self.sx_ptr), memory.read_float(self.sy_ptr)
                directx.draw_line(0.5, 0.5, sx, sy, { r=1, g=0, b=0, a=1 })
            end
        end

        if localplayer:is_ped_shooting() and not entity.is_entity_dead(pped) then
            local pcoords = players.get_position(players.user())
            local weapon_hash = localplayer:get_selected_ped_weapon()
            local damage = entity.get_entity_health(pped) + ped.get_ped_armour(pped)
            local speed = entity.get_entity_speed(pped)
            local from = ped.get_ped_bone_coords(pped, 39317, 0.0, 0.0, 0.0)
            local to = ped.get_ped_bone_coords(pped, 31086, 0.0, 0.0, 0.0)

            if ped.is_ped_in_any_vehicle(pped) then
                local distance = coords:distance(pcoords)
                local time = distance / speed
                local velocity = entity.get_entity_velocity(pped)
                local prediction = v3.new(velocity.x * time, velocity.y * time, velocity.z * time)
                to:add(prediction)
            else
                from = ped.get_ped_bone_coords(pped, 24816, 0.0, 1.0, 0.2)
                to = ped.get_ped_bone_coords(pped, 31086, 0.0, 0.0, 0.0)
            end

            if self.spectate and coords:distance(pcoords) >= 490 then
                local spect = menu.player_root(target):refByRelPath(T'Spectate>Nuts Method')
                if spect:isValid() then
                    spect.value = true
                    util.yield(100)
                    self:ShootBullet(localplayer.entity, weapon_hash, damage, from, to)
                    util.yield(200)
                    spect.value = false
                end
            else
                self:ShootBullet(localplayer.entity, weapon_hash, damage, from, to)
            end
        end
    end

    function TriggerBot()
        if player.get_entity_player_is_free_aiming_at(players.user(), self.ent_ptr) then
            local ent = memory.read_int(self.ent_ptr)
            if ent ~= 0 then
                local model = util.reverse_joaat(entity.get_entity_model(ent))
                local pid = network.network_get_player_index_from_ped(ent)
                if model:find('freemode') then
                    if not entity.is_entity_dead(ent) and not network.is_entity_a_ghost(ent) then
                        if not self.target_friends and S:IsFriend(pid) then return end
                        if not self.targets:IsSet(1 << pid) then return end
                        for i = 0, 8 do
                            pad.set_control_value_next_frame(0, 24, 1)
                        end
                    end
                end
            end
        end
    end

    function UnfairTriggerBot()
        if player.get_entity_player_is_free_aiming_at(players.user(), self.ent_ptr) then
            local ent = memory.read_int(self.ent_ptr)
            if ent ~= 0 then
                local model = util.reverse_joaat(entity.get_entity_model(ent))
                local pid = network.network_get_player_index_from_ped(ent)
                if model:find('freemode') then
                    if not entity.is_entity_dead(ent) and not network.is_entity_a_ghost(ent) then
                        if not self.target_friends and S:IsFriend(pid) then return end
                        if not self.targets:IsSet(1 << pid) then return end
                        for i = 0, 8 do
                            pad.set_control_value_next_frame(0, 24, 1)
                        end
                        local to = ped.get_ped_bone_coords(ent, self.bone, 0.0, 0.0, 0.0)
                        local from = self:GetWeaponBarrelCoords()
                        local localplayer = players.localplayer()
                        local weapon_hash = localplayer:get_selected_ped_weapon()
                        local damage = weapon.get_weapon_damage(weapon_hash, self.bone)
                        self:ShootBullet(localplayer.entity, weapon_hash, damage, from, to)
                    end
                end
            end
        end
    end

    function GetTarget()
        local target = nil
        local player_coords = players.get_position(players.user())
        local weapon_manager = entities.get_weapon_manager(entities.handle_to_pointer(players.user_ped()))
        local current_weapon = memory.read_long(weapon_manager + 0x0020)
        local max_distance = memory.read_float(current_weapon + 0x028C)
        for pid = 0, players.max_players do
            if S:PlayerExists(pid) and pid ~= players.user() and self.targets:IsSet(1 << pid) then
                local player_ped = player.get_player_ped(pid)
                local coords = players.get_position(pid)
                if not entity.is_entity_dead(player_ped) then
                    local distance = player_coords:distance(coords)
                    if distance <= max_distance then
                        if self.ignore_vehicles and ped.is_ped_in_any_vehicle(player_ped) then
                            goto continue
                        end

                        if not self.target_friends and S:IsFriend(pid) then
                            goto continue
                        end

                        if players.is_in_interior(pid) then
                            goto continue
                        end

                        local fov = (self.use_fov) ? self.fov : 180
                        if ped.is_ped_facing_ped(players.user_ped(), player_ped, fov) then
                            target = { pid = pid, ped = player_ped }
                            break
                        end
                    end
                end
            end

            ::continue::
        end

        return target
    end

    function ShootBullet(owner, weapon, damage, from, to)
        misc.shoot_single_bullet_between_coords_ignore_entity(from.x, from.y, from.z, to.x, to.y, to.z, damage, true, weapon, owner, true, false, 100.0, owner, true)
    end

    function GetWeaponBarrelCoords()
        local localplayer = players.localplayer()
        local weapon_hash = localplayer:get_selected_ped_weapon(self.bone)
        local ent = localplayer:get_current_ped_weapon_entity_index(false)
        if ent ~= 0 then
            local coords = entity.get_offset_from_entity_in_world_coords(ent, 0.0, -0.19, 0.0)
            return coords
        end
        return nil
    end

    function GetClosestPlayer()
        local target = nil
        local dist = 20000000.0
        
        for pid = 0, players.max_players do
            if S:PlayerExists(pid) and pid ~= players.user() and self.targets:IsSet(1 << pid) then
                local tpos = players.get_position(pid)
                local kpos = players.get_position(players.user())
                local pped = player.get_player_ped(pid)
                if not self.target_friends and S:IsFriend(pid) then goto continue end
                if not entity.is_entity_dead(pped) and not players.is_in_interior(pid) and not players.is_godmode(pid) then
                    if tpos:distance(kpos) < dist then
                        target = pid
                        dist = tpos:distance(kpos)
                    end
                end
            end
            ::continue::
        end

        return target
    end
end

return PlayerAimbot
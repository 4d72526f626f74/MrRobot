local T, S, H = require('translations'), require('shared'), require('handler')
local Bitfield = require('bitfield')
local VehModels = require('vehicle_models')
local Globals = require('script_globals')
local ScriptOffsets = require('offsets')
local Masks = require('masks')
local Network = require('network')

local shadow_root = menu.shadow_root()

local Offsets = ScriptOffsets.Vehicles.LSCustoms
local Bits = ScriptOffsets.Players.Bits
local SpoofingOffsets = ScriptOffsets.Online.SpoofingOffsets
local PlayerStates = ScriptOffsets.PlayerStates
local VehStateBitfield = ScriptOffsets.VehStateBitfield
local Settings = pluto_new Bitfield(Bits.ForceScriptHost)

local ScriptEvents = {
    'Fake Register CEO', 
            'Fake Register MC', 
            'Fake Register VIP',
            'Fake Off The Radar',
            'Fake Ghost Org',
            'Mugged',
            'Ewo',
            'Ghosted',
            'Destroyed Vehicle Cargo',
            'Cash Stolen',
            'Cash Banked',
            'Cash Removed',
            'Jammer Activated',
            'Delivered Motorcycle',
            'Joined Organisation',
            'Quit Organisation',
            'Marked For Death',
            'Interior Invite',
            'Mugger Killed'
}

local DetachableWheels = {
    {index = 0, name = T'Left Front'},
    {index = 1, name = T'Right Front'},
    {index = 2, name = T'Left Rear'},
    {index = 3, name = T'Right Rear'},
    {index = 4, name = T'Left Middle'},
    {index = 5, name = T'Right Middle'},
}

pluto_class Players
    cayo_targets = {
        'Tequila',
        'Madrazo Files',
        'Pink Diamond',
        'Bearer Bonds',
        'Ruby Necklace',
        'Sapphire Panther',
        'Invalid'
    }

    function __construct(root)
        self.spawned_vehicles = {}
        self.gamer_handle = memory.alloc(104)
        self.updating = {
            player_info = false,
            personal_vehicle = false,
            bounty = false,
            wheels_states = false
        }

        local partial = S:Partial(self.PlayerLoop, self)
        H.PlayerLoop = partial
    end

    function PlayerLoop(pid, root)
        network.network_handle_from_player(pid, self.gamer_handle, 104 // 8)
        S:AddPlayer(pid)
        if network.network_is_friend(self.gamer_handle) and pid ~= players.user() then S:AddFriend(pid) end

        local name = players.get_name(pid)
        root:divider('Mr.Robot')
        self.root = root:list('Mr.Robot', {}, 'Mr.Robot')

        self.pinfo = self.root:list(T'Player Info', {}, T'Player Info', nil, nil, || -> self:UpdatePlayerInfo(pid))
        self.pinfo:readonly('', '') -- badsport
        self.pinfo:readonly('', '') -- cheater

        self.pv = self.root:list(T'Personal Vehicle', {}, T'Personal Vehicle', nil, nil, || -> self:UpdatePersonalVehicle(pid))
        self.pv:divider(T'Vehicle Info')
        self.pv:readonly('', '') -- model
        self.pv:readonly('', '') -- health
        self.pv:readonly('', '') -- godmode
        self.pv:readonly('', '') -- frozen
        self.pv:readonly('', '') -- invisible
        self.pv:readonly('', '') -- can migrate

        self.pv:divider('')
        self.pv:toggle(T'Force Script Host', {}, T'Forces you to become script host (helps with trolling features)', function(state)
            Settings:SetBool(Bits.ForceScriptHost, state)
        end, Settings:IsSet(Bits.ForceScriptHost))

        if pid ~= players.user() then
            self.pv:toggle(T'Spectate', {}, T'Spectate the player', function(state)
                local spect = menu.ref_by_rel_path(root, T'Spectate>Nuts Method')
                if spect:isValid() then
                    spect.value = state
                end
            end)
        end

        local lock_doors
        ock_doors = self.pv:toggle_loop(T'Lock Door', {}, T'Locks the door of the player\'s vehicle', function()
            if Settings:IsSet(Bits.ForceScriptHost) then Network.BecomeScriptHost() end
            local veh = Network.GetPVFromNetworkID(pid)
            if veh ~= 0 then
                if Network.RequestControl(veh) then
                    vehicle.set_vehicle_doors_locked_for_player(veh, pid, true)
                    vehicle.set_vehicle_doors_shut(veh, true)
                else
                    Network.FailedToRequestControl(veh)
                end
            else
                lock_doors.value = false
                self:OutOfRange()
            end
        end, function()
            local veh = Network.GetPVFromNetworkID(pid)
            if veh ~= 0 then
                vehicle.set_vehicle_doors_locked_for_player(veh, pid, false)
                vehicle.set_vehicle_doors_shut(veh, false)
            end
        end)

        local deny_request
        deny_requests = self.pv:toggle_loop(T'Deny Control Requests', {}, T'Prevent the player from being able to take control over their vehicle', function()
            local veh = Network.GetPVFromNetworkID(pid)
            if veh ~= 0 then
                if entities.get_can_migrate(veh) then
                    entities.set_can_migrate(veh, false)
                end
            else
                deny_requests.value = false
                self:OutOfRange()
            end
        end, function()
            local veh = Network.GetPVFromNetworkID(pid)
            if veh ~= 0 then
                if not entities.get_can_migrate(veh) then
                    entities.set_can_migrate(veh, true)
                end
            end
        end)

        local conceal_vehicle
        conceal_vehicle = self.pv:toggle_loop(T'Conceal Vehicle', {}, T'Stops the vehicle from being networked', function()
            local veh = Network.GetPVFromNetworkID(pid)
            if veh ~= 0 then
                if Network.RequestControl(veh) then
                    if not network.network_is_entity_concealed(veh) then
                        network.network_conceal_entity(veh, true)
                    end
                else
                    Network.FailedToRequestControl(veh)
                end
            end
        end, function()
            local veh = Network.GetPVFromNetworkID(pid)
            if veh ~= 0 then
                if Network.RequestControl(veh) then
                    if network.network_is_entity_concealed(veh) then
                        network.network_conceal_entity(veh, false)
                    end
                else
                    Network.FailedToRequestControl(veh)
                end
            end
        end)

        local send_to_heaven
        send_to_heaven = self.pv:toggle_loop(T'Send Vehicle To Heaven', {}, T'Send the players vehicle to heaven, this does not work on every vehicle!', function()
            if Settings:IsSet(Bits.ForceScriptHost) then Network.BecomeScriptHost() end
            local veh = Network.GetPVFromNetworkID(pid)
            if veh ~= 0 then
                if Network.RequestControl(veh) then
                    vehicle.set_vehicle_doors_shut(veh, false)
                else
                    Network.FailedToRequestControl(veh)
                end
            else
                send_to_heaven.value = false
                self:OutOfRange()
            end
        end)

        self.pv:divider('')
        self.pv:action(T'Add Explosive Device', {}, T'Add explosive device to the players vehicle', function()
            local veh = Network.GetPVFromNetworkID(pid)
            if veh ~= 0 then
                if Network.RequestControl(veh) then
                    vehicle.add_vehicle_phone_explosive_device(veh)
                else
                    Network.FailedToRequestControl(veh)
                end
            else
                local veh = ped.get_vehicle_ped_is_in(player.get_player_ped(pid), false)
                if veh ~= 0 then
                    if Network.RequestControl(veh) then
                        vehicle.add_vehicle_phone_explosive_device(veh)
                    else
                        Network.FailedToRequestControl(veh)
                    end
                end
            end
        end)

        self.pv:action(T'Clear Explosive Device', {}, T 'Removes the explosive device from the players vehicle', function()
            local veh = Network.GetPVFromNetworkID(pid)
            if veh ~= 0 then
                if Network.RequestControl(veh) then
                    vehicle.clear_vehicle_phone_explosive_device(veh)
                else
                    Network.FailedToRequestControl(veh)
                end
            else
                local veh = ped.get_vehicle_ped_is_in(player.get_player_ped(pid), false)
                if veh ~= 0 then
                    if Network.RequestControl(veh) then
                        vehicle.clear_vehicle_phone_explosive_device(veh)
                    else
                        Network.FailedToRequestControl(veh)
                    end
                end
            end
        end)

        self.pv:action(T'Detonate Explosive Device', {}, T'Detonate the explosive device', function()
            local veh = Network.GetPVFromNetworkID(pid)
            if veh ~= 0 then
                if Network.RequestControl(veh) then
                    vehicle.detonate_vehicle_phone_explosive_device(veh)
                else
                    Network.FailedToRequestControl(veh)
                end
            else
                local veh = ped.get_vehicle_ped_is_in(player.get_player_ped(pid), false)
                if veh ~= 0 then
                    if Network.RequestControl(veh) then
                        vehicle.detonate_vehicle_phone_explosive_device(veh)
                    else
                        Network.FailedToRequestControl(veh)
                    end
                end
            end
        end)

        self.pv:action(T'Force Respawn', {}, T'Force the players vehicle to respawn', function()
            if Settings:IsSet(Bits.ForceScriptHost) then Network.BecomeScriptHost() end
            self:ForceVehicleRespawn(pid)
        end)

        self.pv:action(T'Unlock Vehicle', {}, T'Bypass vehicle access settings', function()
            local veh = Network.GetPVFromNetworkID(pid)
            if veh ~= 0 then
                vehicle.set_vehicle_doors_locked_for_player(veh, players.user(), false)
            end
        end)

        self.pv:action(T'Repair', {}, T'Repair their vehicle', function()
            local veh = Network.GetPVFromNetworkID(pid)
            if veh ~= 0 then
                if Network.RequestControl(veh) then
                    vehicle.set_vehicle_fixed(veh)
                else
                    Network.FailedToRequestControl(veh)
                end
            else
                self:OutOfRange()
            end
        end)
        self.pv:divider('')
        self.veh_kicks = self.pv:list(T'Kicks', {}, T'Vehicle kicks')
        self.veh_kicks:action(T'Takeover Kick', {}, T'Takeover kick (a discrete vehicle kick)', function()
            if Settings:IsSet(Bits.ForceScriptHost) then Network.BecomeScriptHost() end
            self:TakeoverKick(pid)
        end)

        self.veh_kicks:action(T'Regular Kick', {}, T'Interaction menu kick', function()
            self:RegularKick(pid)
        end)

        self.trolling = self.root:list(T'Trolling', {}, T'Trolling')
        if pid ~= players.user() then
            self.organisation = self.trolling:list(T'Organisation', {}, T'Organisation')

            self.organisation:toggle_loop(T'Force Join', {}, T'Force join the players organisation, you will instatly rejoin if they kick you', function()
                Network.SetOrganisationID(pid)
            end)
        end

        self.script_events = self.trolling:list(T'Script Events', {}, T'Script Events')
        local event_amount = self.script_events:slider(T'Amount', {T'amount'}, T'Amount of times to trigger the event', 1, math.max_int, 1, 1, function(value) end)
        local event_choice = self.script_events:list_select(T'Event', {}, T'The event to send', ScriptEvents, 1, function(index) end)
        self.script_events:action(T'Send', {}, T 'Send the event to the player', function()
            local index = event_choice.value
            local event = ScriptEvents[index]
            local player_id = players.user()
            local amount = event_amount.value

            pluto_switch event do
                case 'Fake Register CEO':
                    S:RegisterCEO(pid)
                    break
                case 'Fake Register MC':
                    S:RegisterMC(pid)
                    break
                case 'Fake Register VIP':
                    S:RegisterVIP(pid)
                    break
                case 'Fake Off The Radar':
                    S:OffRadar(pid)
                    break
                case 'Fake Ghost Org':
                    S:GhostOrg(pid)
                    break
                case 'Mugged':
                    S:SuccessfullyMugged(pid, math.max_int)
                    break
                case 'Ewo':
                    S:PlayerEwo(pid, player_id)
                    break
                case 'Ghosted':
                    S:BecomeGhosted(pid, player_id)
                    break
                case 'Destroyed Vehicle Cargo':
                    S:DestroyedVehicleCargo(pid, player_id)
                    break
                case 'Cash Stolen':
                    S:CashStolen(pid, amount)
                    break
                case 'Cash Banked':
                    S:CashBanked(pid, amount)
                    break
                case 'Cash Removed':
                    S:CashRemoved(pid, amount)
                    break
                case 'Jammer Activated':
                    S:JammerActivated(pid)
                    break
                case 'Delivered Motorcycle':
                    S:DeliveredMotorcycle(pid, player_id)
                    break
                case 'Joined Organisation':
                    S:JoinedOrg(pid, player_id)
                    break
                case 'Quit Organisation':
                    S:QuitOrg(pid, player_id)
                    break
                case 'Marked For Death':
                    S:MarkedForDeath(pid, player_id)
                    break
                case 'Interior Invite':
                    S:InteriorInvite(pid, PlayerID)
                    break
                case 'Mugger Killed':
                    S:MuggerKilled(pid)
                    break
            end
        end)

        self.bounty = self.trolling:list(T'Bounty', {}, T'Bounty', nil, nil, || -> self:UpdateBountyInfo(pid))
        self.bounty:divider(T'Bounty Info')
        self.bounty:readonly('', '') -- Active
        self.bounty:readonly('', '') -- Amount
        self.bounty:readonly('', '') -- Reward
        self.bounty:readonly('', '') -- Modded
        self.bounty:divider('')

        local bounty_input_amount
        bounty_input_amount = self.bounty:text_input(T'Bounty', {T'rpbounty'}, T'Set an anonymous undetectable bounty on the player', function(amount)
            amount = tonumber(amount)
            if amount ~= nil then
                if amount < 0 or amount > 10000 then
                    return util.toast(T'Invalid amount')
                end

                Network.SetBounty(pid, 0, false)
                Network.SetBounty(pid, amount, true)
            end
        end, '10000')

        local bounty_reward_amount
        bounty_reward_amount = self.bounty:text_input(T'Reward', {T'rpbountyreward'}, T'Set the reward amount for the players bounty (anyone that kills them will get this amount instead of the amount that was set)', function(amount)
            amount = tonumber(amount)
            if amount ~= nil then
                if amount < 0 or amount > 10000 then
                    return util.toast(T'Invalid amount')
                end

                Network.SetBountyReward(pid, amount)
            end
        end, '10000')
        self.bounty:divider('')

        self.bounty:action(T'Max Bounty', {T'rpmaxbounty'}, T'Set the players bounty to the maximum amount', function()
            Network.SetBounty(pid, 0, false)
            Network.SetBounty(pid, 10000, true)
        end)

        self.bounty:action(T'Remove Bounty', {T'rpremovebounty'}, T'Remove the bounty from the player', function()
            Network.SetBounty(pid, 0, false)
        end)

        self.bounty:divider('')
        self.bounty:toggle_loop(T'Bounty Loop', {T'rpbountyloop'}, T'Loop set a bounty on the player', function()
            local amount = tonumber(bounty_input_amount.value)
            if amount ~= nil then
                if amount < 0 or amount > 10000 then
                    return util.toast(T'Invalid amount')
                end

                Network.SetBounty(pid, 0, false)
                Network.SetBounty(pid, amount, true)
            end
        end)

        self.bounty:toggle_loop(T'Set Bounty Reward', {T'rpsetbountyreward'}, T'Set the reward amount for the players bounty', function()
            local amount = tonumber(bounty_reward_amount.value)
            if amount ~= nil then
                if amount < 0 or amount > 10000 then
                    return util.toast(T'Invalid amount')
                end

                Network.SetBountyReward(pid, amount)
            end
        end)

        self.bounty:toggle_loop(T'Max Bounty Reward', {T'rpmaxbountyrewardloop'}, T'Set the players bounty reward to the maximum amount', function()
            Network.SetBountyReward(pid, 10000)
        end)

        self.bounty:toggle_loop(T'Remove Bounty Reward', {T'rpremovebountyrewardloop'}, T'Remove the bounty reward for the player', function()
            Network.SetBountyReward(pid, 0)
        end)

        self.toxic = self.trolling:list(T'Toxic', {}, T'Toxic')
        self.toxic:action(T'Send Corrupted Invite', {}, T'Send a corrupted invite to the player', function()
            memory.write_int(memory.script_global(Globals.Interior), -1)
            S:InteriorInvite(pid)
        end)

        self.veh_trolling = self.trolling:list(T'Vehicle', {}, T'Vehicle')
        self.wheels = self.veh_trolling:list(T'Wheels', {}, T'Wheels', nil, nil, || -> self:UpdateWheelsInfo(pid))
        self.wheels:divider(T'Wheels')
        self.wheels:readonly(T'Wheel 1: ?', '') -- index 1
        self.wheels:readonly(T'Wheel 2: ?', '') -- index 2
        self.wheels:readonly(T'Wheel 3: ?', '') -- index 3
        self.wheels:readonly(T'Wheel 4: ?', '') -- index 4
        self.wheels:readonly(T'Wheel 5: ?', '') -- index 5
        self.wheels:readonly(T'Wheel 6: ?', '') -- index 6
        self.wheels:readonly(T'Wheel 7: ?', '') -- index 7
        self.wheels:readonly(T'Wheel 8: ?', '') -- index 8
        self.wheels:divider('')

        self.individual_wheels = self.wheels:list(T'Individual Wheels', {}, T'Individual Wheels')
        self.wheels:action(T'Detach Wheels', {}, T'Detach wheels from the players vehicle', function()
            local player_ped = player.get_player_ped(pid)
            local veh = ped.get_vehicle_ped_is_in(player_ped, false)
            if veh ~= 0 then
                local ptr = entities.handle_to_pointer(veh)
                if ptr ~= 0 then
                    if Network.RequestControl(veh) then
                        local state = memory.read_short(ptr + 0xA48)
                        for i = 0, 7 do
                            if not memory.bits:check(state, i) then
                                entities.detach_wheel(ptr, i)
                            end
                        end
                    else
                        Network.FailedToRequestControl(veh)
                    end
                end
            end
        end)

        for DetachableWheels as wheel do
            self.individual_wheels:action(wheel.name, {}, T'Detach a wheel from the players vehicle', function()
                local player_ped = player.get_player_ped(pid)
                local veh = ped.get_vehicle_ped_is_in(player_ped, false)
                if veh ~= 0 then
                    local ptr = entities.handle_to_pointer(veh)
                    if ptr ~= 0 then
                        if Network.RequestControl(veh) then
                            entities.detach_wheel(ptr, wheel.index)
                        else
                            Network.FailedToRequestControl(veh)
                        end
                    end
                end
            end)
        end

        self.wheels:toggle_loop(T'Wheels Spam', {}, T'Spam the player with wheels by detaching and fixing their vehicle', function()
            local player_ped = player.get_player_ped(pid)
            local veh = ped.get_vehicle_ped_is_in(player_ped, false)
            if veh ~= 0 then
                local ptr = entities.handle_to_pointer(veh)
                if ptr ~= 0 then
                    if Network.RequestControl(veh) then
                        for i = 0, 7 do
                            entities.detach_wheel(ptr, i)
                        end
                        util.yield(50)
                        vehicle.set_vehicle_fixed(veh)
                    else
                        Network.FailedToRequestControl(veh)
                    end
                end
            end
        end)

        self.crashes = self.trolling:list(T'Crashes', {}, T'Crashes')
        self.crashes:action(T'Wheel Crash', {}, T'Crashes the player with a buggy wheel model', function()
            S:PlayAnimation($'{filesystem.script_root()}/images/Loser.png', 1.7, 0.20)
        end)

        self.trolling:divider('')
        self.trolling:action(T'Owned Orbital Strike', {}, T'Launch an owned orbital strike on the player', function()
            S:RequestNamedPtfxAsset('scr_xm_orbital')
            local player_ped = player.get_player_ped(pid)
            local pos = players.get_position(pid)
            Network.OrbitalCannon(true)

            graphics.start_networked_particle_fx_non_looped_on_entity('scr_xm_orbital_blast', player_ped, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10.0, false, false, false)
            graphics.start_networked_particle_fx_non_looped_on_entity('scr_xm_orbital_blast', player_ped, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 20.0, false, false, false)
            graphics.start_networked_particle_fx_non_looped_on_entity('scr_xm_orbital_blast', player_ped, 0.0, 10.0, 0.0, 0.0, 0.0, 0.0, 30.0, false, false, false)

            for i = 0, 5 do
                fire.add_owned_explosion(players.user_ped(), pos.x + (10 * i), pos.y + (10 * i), pos.z + (10 * i), 60, 100000.0, true, false, 1.0)
            end

            util.yield(1000)
            Network.OrbitalCannon(false)
        end)

        self.trolling:action(T'Oribtal Strike', {}, T'Launch an orbital strike on the player', function()
            S:RequestNamedPtfxAsset('scr_xm_orbital')
            local player_ped = player.get_player_ped(pid)
            local pos = players.get_position(pid)

            graphics.start_networked_particle_fx_non_looped_on_entity('scr_xm_orbital_blast', player_ped, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 10.0, false, false, false)
            graphics.start_networked_particle_fx_non_looped_on_entity('scr_xm_orbital_blast', player_ped, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 20.0, false, false, false)
            graphics.start_networked_particle_fx_non_looped_on_entity('scr_xm_orbital_blast', player_ped, 0.0, 10.0, 0.0, 0.0, 0.0, 0.0, 30.0, false, false, false)

            for i = 0, 5 do
                fire.add_explosion(pos.x + (10 * i), pos.y + (10 * i), pos.z + (10 * i), 60, 100000.0, true, false, 1.0)
            end
        end)

        self.trolling:action(T'Send Mugger', {}, T'Send a mugger to mug the player', function()
            Network.SendAttacker(pid, 'Mugger')
        end)

        self.trolling:action(T'Send Mercenaries', {}, T'Send mercenaries to kill the player', function()
            Network.SendAttacker(pid, 'Mercenaries')
        end)

        self.trolling:action(T'Send Strike Team (Level 1)', {}, T'Send a strike team to kill the player', function()
            Network.SendAttacker(pid, 'Strike Team', 1)
        end)

        self.trolling:action(T'Send Strike Team (Level 2)', {}, T'Send a strike team to kill the player', function()
            Network.SendAttacker(pid, 'Strike Team', 2)
        end)

        self.trolling:action(T'Send Strike Team (Level 3)', {}, T'Send a strike team to kill the player', function()
            Network.SendAttacker(pid, 'Strike Team', 3)
        end)

        self.trolling:divider('')
        self.trolling:toggle_loop(T'Block Passive Mode', {}, T'Prevent the player from going passive', function()
            Network.SetBounty(pid, 0, true)
        end, function()
            Network.SetBounty(pid, 0, false)
        end)

        self.friendly = self.root:list(T'Friendly', {}, T'Friendly')
        self.friendly_bounty = self.friendly:list(T'Bounty', {}, T'Bounty')
        self.friendly_bounty:toggle_loop(T'Anti-Bounty', {}, T'Prevent other players from placing a bounty on them', function()
            if players.get_bounty(pid) ~= nil then
                Network.SetBounty(pid, 0, false)
            end
        end)

        self.friendly_bounty:toggle_loop(T'Anti-Modded Bounty', {}, T'Prevent modders from placing a modded bounty on them', function()
            local amount = players.get_bounty(pid)
            if amount ~= nil and Network.IsBountyModded(amount or 1000) then
                Network.SetBounty(pid, 0, false)
            end
        end)

        self.neutral = self.root:list(T'Neutral', {}, T'Neutral')
        self.cayo = self.neutral:list(T'Cayo Perico', {}, T'Cayo Perico')
        self.target_choice = self.cayo:list_select(T'Target', {}, T'Target that will be set for this player in the heist', self.cayo_targets, 1, function(index) end)
        self.cayo:toggle_loop(T'Set Target', {}, T'Set the target for this player in the heist (changing the target mid-heist will change the take)', function()
            local target = memory.script_global(Globals:PlayerCayoPrimaryTarget(pid))
            memory.write_int(target, self.target_choice.value - 1)
        end)
    end

    function UpdatePlayerInfo(pid)
        if not self.updating.player_info then
            self.updating.player_info = true
            util.create_tick_handler(function()
                local item = menu.get_current_menu_list()
                if item.menu_name ~= T'Player Info' then 
                    self.updating.player_info = false
                    return false 
                end
                local children = item:getChildren()
                if #children == 2 then
                    local badsport, cheater = children[1], children[2]
                    if badsport:isValid() then
                        badsport.menu_name = T'Badsport: ' .. ((Network.StatsPlayerIsBadSport(pid)) ? T'Yes' : T'No')
                    end
                    if cheater:isValid() then
                        cheater.menu_name = T'Cheater: ' .. ((Network.StatsPlayerIsCheater(pid)) ? T'Yes' : T'No')
                    end
                end
            end)
        end
    end

    function UpdatePersonalVehicle(pid)
        if not self.updating.personal_vehicle then
            self.updating.personal_vehicle = true
            util.create_tick_handler(function()
                local item = menu.get_current_menu_list()
                if item.menu_name ~= T'Personal Vehicle' then 
                    self.updating.personal_vehicle = false
                    return false 
                end
                local veh = Network.GetPVFromNetworkID(pid)
                local children = item:getChildren()
                local model, health, godmode, frozen, invisible, can_migrate = children[2], children[3], children[4], children[5], children[6], children[7]

                if model:isValid() then
                    if veh ~= 0 then
                        model.menu_name = T'Model: ' .. util.get_label_text(util.reverse_joaat(entity.get_entity_model(veh)))
                    else
                        model.menu_name = T'Model: None'
                    end
                end

                if health:isValid() then
                    if veh ~= 0 then
                        health.menu_name = T'Health: ' .. entity.get_entity_health(veh)
                    else
                        health.menu_name = T'Health: None'
                    end
                end

                if godmode:isValid() then
                    if veh ~= 0 then
                        godmode.menu_name = T'Godmode: ' .. ((self:IsEntityGodmode(veh)) ? T'Yes' : T'No')
                    else
                        godmode.menu_name = T'Godmode: None'
                    end
                end

                if frozen:isValid() then
                    if veh ~= 0 then
                        frozen.menu_name = T'Frozen: ' .. ((self:IsEntityFrozen(veh)) ? T'Yes' : T'No')
                    else
                        frozen.menu_name = T'Frozen: None'
                    end
                end

                if invisible:isValid() then
                    if veh ~= 0 then
                        invisible.menu_name = T'Invisible: ' .. ((self:IsEntityInvisible(veh)) ? T'Yes' : T'No')
                    else
                        invisible.menu_name = T'Invisible: None'
                    end
                end

                if can_migrate:isValid() then
                    if veh ~= 0 then
                        can_migrate.menu_name = T'Can Migrate: ' .. ((entities.get_can_migrate(veh)) ? T'Yes' : T'No')
                    else
                        can_migrate.menu_name = T'Can Migrate: None'
                    end
                end
            end)
        end
    end

    function UpdateBountyInfo(pid)
        if not self.updating.bounty then
            self.updating.bounty = true
            util.create_tick_handler(function()
                local item = menu.get_current_menu_list()
                if item.menu_name ~= T'Bounty' then
                    self.updating.bounty = false
                    return false
                end
                local children = item:getChildren()
                local active, amount, reward, modded = children[2], children[3], children[4], children[5]

                local bounty = Network.GetBounty(pid)
                if active:isValid() then
                    active.menu_name = T'Active: ' .. ((bounty.has_bounty) ? T'Yes' : T'No')
                end

                if amount:isValid() then
                    amount.menu_name = T'Amount: ' .. bounty.amount
                end

                if reward:isValid() then
                    reward.menu_name = T'Reward: ' .. bounty.reward
                end

                if modded:isValid() then
                    modded.menu_name = T'Modded: ' .. ((Network.IsBountyModded(bounty.amount) and bounty.has_bounty) ? T'Yes' : T'No')
                end
            end)
        end
    end

    function UpdateWheelsInfo(pid)
        if not self.updating.wheels_states then
            self.updating.wheels_states = true
            util.create_tick_handler(function()
                local item = menu.get_current_menu_list()
                if item.menu_name ~= T'Wheels' then
                    self.updating.wheels_states = false
                    return false
                end
                local player_ped = player.get_player_ped(pid)
                local veh = ped.get_vehicle_ped_is_in(player_ped, false)
                if veh ~= 0 then
                    local ptr = entities.handle_to_pointer(veh)
                    if ptr ~= 0 then
                        local state = memory.read_short(ptr + 0xA48)
                        local children = item:getChildren()
                        local index1, index2, index3, index4, index5, index6, index7, index8 = children[2], children[3], children[4], children[5], children[6], children[7], children[8], children[9]
                        if index1:isValid() then
                            index1.menu_name = T'Wheel 1: ' .. ((state & (1 << 0) ~= (1 << 0)) ? T'Attached' : T'Detached')
                        end

                        if index2:isValid() then
                            index2.menu_name = T'Wheel 2: ' .. ((state & (1 << 1) ~= (1 << 1)) ? T'Attached' : T'Detached')
                        end

                        if index3:isValid() then
                            index3.menu_name = T'Wheel 3: ' .. ((state & (1 << 2) ~= (1 << 2)) ? T'Attached' : T'Detached')
                        end

                        if index4:isValid() then
                            index4.menu_name = T'Wheel 4: ' .. ((state & (1 << 3) ~= (1 << 3)) ? T'Attached' : T'Detached')
                        end

                        if index5:isValid() then
                            index5.menu_name = T'Wheel 5: ' .. ((state & (1 << 4) ~= (1 << 4)) ? T'Attached' : T'Detached')
                        end

                        if index6:isValid() then
                            index6.menu_name = T'Wheel 6: ' .. ((state & (1 << 5) ~= (1 << 5)) ? T'Attached' : T'Detached')
                        end

                        if index7:isValid() then
                            index7.menu_name = T'Wheel 7: ' .. ((state & (1 << 6) ~= (1 << 6)) ? T'Attached' : T'Detached')
                        end

                        if index8:isValid() then
                            index8.menu_name = T'Wheel 8: ' .. ((state & (1 << 7) ~= (1 << 7)) ? T'Attached' : T'Detached')
                        end
                    else
                        if index1:isValid() then
                            index1.menu_name = T'Wheel 1: ?'
                        end

                        if index2:isValid() then
                            index2.menu_name = T'Wheel 2: ?'
                        end

                        if index3:isValid() then
                            index3.menu_name = T'Wheel 3: ?'
                        end

                        if index4:isValid() then
                            index4.menu_name = T'Wheel 4: ?'
                        end

                        if index5:isValid() then
                            index5.menu_name = T'Wheel 5: ?'
                        end

                        if index6:isValid() then
                            index6.menu_name = T'Wheel 6: ?'
                        end

                        if index7:isValid() then
                            index7.menu_name = T'Wheel 7: ?'
                        end

                        if index8:isValid() then
                            index8.menu_name = T'Wheel 8: ?'
                        end
                    end
                end
            end)
        end
    end

    function IsEntityGodmode(ent)
        local ptr = entities.handle_to_pointer(ent)
        local mask = 0x1F0
        if ptr ~= 0 then
            local damage_flags = memory.read_int(ptr + 0x188)
            return damage_flags & mask ~= 0
        end
        return false
    end

    function IsEntityFrozen(ent)
        local ptr = entities.handle_to_pointer(ent)
        if ptr ~= 0 then
            return memory.read_long(ptr + 0x0028) & (1 << 49) ~= 0
        end
        return false
    end

    function IsEntityInvisible(ent)
        local ptr = entities.handle_to_pointer(ent)
        local mask = 0x10000100000000
        if ptr ~= 0 then
            return memory.read_long(ptr + 0x0028) & mask == 0
        end
        return false
    end

    function OutOfRange()
        util.toast(T'Player is out of range, spectate them or get closer!')
    end

    function ForceVehicleRespawn(pid)
        local veh = Network.GetPVFromNetworkID(pid)
        if veh ~= 0 then
            local target_nethash = network.network_hash_from_player_handle(pid)
            if not ped.is_ped_in_any_vehicle(player.get_player_ped(pid)) then
                if Network.RequestControl(veh) then
                    self:SoftSpoof(pid, true)
                    decorator.decor_set_int(veh, 'Previous_Owner', target_nethash)
                else
                    Network.FailedToRequestControl(veh)
                end
            else
                util.toast(T'They are in their vehicle, kick them from it first!')
            end
        else
            self:OutOfRange()
        end
    end

    function SoftSpoof(pid, state)
        local player_id = players.user()
        if state then
            Network.SetPVNetworkID(player_id, Network.GetPVNetworkID(pid))
        else
            Network.SetPVNetworkID(player_id, -1)
        end
    end

    function SpoofVehicle(pid, state)
        local veh = Network.GetPVFromNetworkID(pid)
        local target_nethash, my_nethash = network.network_hash_from_player_handle(pid), network.network_hash_from_player_handle(players.user())
        if veh ~= 0 then
            if state then
                S:RequestPVInSlot(0)
                Network.SetPVNetworkID(players.user(), Network.GetPVNetworkID(pid))
                decorator.decor_set_int(veh, 'Player_Vehicle', my_nethash)
                decorator.decor_set_int(veh, 'Previous_Owner', my_nethash)
            else
                decorator.decor_set_int(veh, 'Player_Vehicle', target_nethash)
                decorator.decor_set_int(veh, 'Previous_Owner', target_nethash)
                S:ReturnPVInSlot(0)
                Network.SetPVNetworkID(players.user(), -1)
            end
        else
            self:OutOfRange()
        end
    end

    function TakeoverKick(pid)
        local veh = Network.GetPVFromNetworkID(pid)
        local player_id = players.user()
        if veh ~= 0 then
            S:ReturnActivePV()
            local my_nethash = network.network_hash_from_player_handle(player_id)
            self:SpoofVehicle(pid, true)
            util.yield(1000)
            Network.VehicleKick(pid)

            repeat
                util.yield_once()
            until not ped.is_ped_in_any_vehicle(player.get_player_ped(pid), false)
            util.yield(200)
            self:SpoofVehicle(pid, false)
        else
            self:OutOfRange()
        end
    end

    function RegularKick(pid)
        local veh = Network.GetPVFromNetworkID(pid)
        local player_id = players.user()
        if veh ~= 0 then
            S:ReturnActivePV()
            local my_nethash = network.network_hash_from_player_handle(player_id)
            local target_nethash = network.network_hash_from_player_handle(pid)
            Network.SetPVNetworkID(player_id, Network.GetPVNetworkID(pid))
            decorator.decor_set_int(veh, 'MPBitset', 0)
        else
            self:OutOfRange()
        end
    end
end

return Players
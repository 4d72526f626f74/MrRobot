local T, S, H = require('translations'), require('shared'), require('handler')
local Bitfield = require('bitfield')
local VehModels = require('vehicle_models')
local G = require('script_globals')
local Globals = G.globals
local ScriptOffsets = require('offsets')
local Network = require('network')
local Notifications = require('notifications')

local Bits = ScriptOffsets.Online.Bits
local VehicleOffsets = ScriptOffsets.Vehicles.LSCustoms
local Offsets = ScriptOffsets.Online.RequestOffsets
local KosatkaStats = ScriptOffsets.Online.KosatkaStats
local LesterLocate = ScriptOffsets.Online.LesterLocate
local CEOVehicle = ScriptOffsets.Online.CEOVehicle
local SettingsBits = S.SettingsBits

local Settings = pluto_new Bitfield(Bits.ExcludeSelf | Bits.ExcludeFriends)

pluto_class Online
    function __construct(root)
        self.root = root:list(T'Online', {T'ronline'}, '')
        self.properties = {}
        self.tune = menu.ref_by_path('Vehicle>Los Santos Customs>Upgrade')

        for k, v in pairs(S.PropertyIds) do table.insert(self.properties, k) end
        self.properties_data = S:SortTable(self.properties, |a, b| -> a < b)
        self.properties = S:SortTableIndexed(self.properties, |a, b| -> a < b)

        self.stand_pos_spoof = menu.ref_by_command_name('spoofpos')
        self.stand_spoofed_pos = menu.ref_by_command_name('spoofedposition')

        self.updating = {
            player_sessions = false,
            invites = false
        }

        self.esp_colours = {
            bone = { r=1, g=0, b=0, a=1 },
            box = { r=1, g=0, b=0, a=1 },
            name = { r=1, g=0, b=0, a=1 }
        }

        self:Init()
    end

    function Init()
        self:CreateFakeNotifs()
        self:CreateServices()
        self:CreateOrganisation()
        self:CreateBounty()
        self:CreateSpoofing()
        self:CreateGhosting()
        self:CreateOther()
        self:CreateCasino()
        self:CreateStoreHoldUps()
        self:CreateTaxiService()
        self:CreateATM()
        self:CreateCargo()
        self:CreateMoney()
        self:CreateYeti()
        self:CreateTutorialSessions()
        self:CreateBlameKill()

        H.BlameKillAdd = S:Partial(self.BlameKillAdd, self)
        H.BlameKillRemove = S:Partial(self.BlameKillRemove, self)

        self.root:divider('')
        self.root:toggle_loop(T'Anti-Ghosted', {}, T'Prevent other players from becoming ghosted to you', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) and pid ~= players.user() then
                    local entity = S.NewEntity(player.get_player_ped(pid))
                    if entity:is_entity_a_ghost() then
                        Network.SetBounty(pid, -1, true)
                        util.yield_once()
                        Network.SetBounty(pid, -1, false)
                    end
                end
            end
        end)

        self.root:toggle_loop(T'Block Passive Mode', {}, T'Prevent players from going passive', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) and pid ~= players.user() then
                    Network.SetBounty(pid, -1, true)
                end
            end
        end, function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) and pid ~= players.user() then
                    Network.SetBounty(pid, -1, false)
                end
            end
        end)

        self.root:toggle_loop(T'Display Players With BST', {}, T'Show all players that are using BST', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) and pid ~= players.user() then
                    local ped = player.get_player_ped(pid)
                    local ptr = entities.handle_to_pointer(ped)
                    if ptr ~= 0 then
                        local player_info = entities.get_player_info(ptr)
                        if player_info then
                            local weapon_defense = memory.read_float(player_info + 0x0D60)
                            if weapon_defense < 0.99 then
                                util.draw_debug_text(players.get_name(pid) .. ' is using BST')
                            end
                        end
                    end
                end
            end
        end)

        self.root:toggle(T'Block Orbital Cannon (M1)', {}, T'Block the orbital cannon from being used on you', function(state)
            local orbital = Globals.OrbitalCannonCounterM1:g()
            memory.write_int(orbital, state ? 10 : 4)
        end)

        self.block_oc_m2 = self.root:toggle(T'Block Orbital Cannon (M2)', {}, T'Block the orbital cannon from being used on you', function(state)
            util.create_tick_handler(function()
                local orbital = Globals.OrbitalCannonCounterM2:g()
                memory.write_int(orbital, memory.bits:setbool(memory.read_int(orbital), 1 << 3, state))

                if not self.block_oc_m2.value then
                    return false
                end
            end)
        end)

        self.fake_lag = self.root:toggle_loop(T'Fake Lag', {}, T'Create some artificial lag', function()
            if self.stand_pos_spoof.value then
                local base = Globals.PlayerBase:g()
                local coords = v3.new(v3.get(base + 0x678))
                self.stand_spoofed_pos:trigger($'{coords.x}, {coords.y}, {coords.z}')
            else
                self.stand_pos_spoof:trigger()
            end
        end, function()
            self.stand_pos_spoof.value = false
        end)

        self.root:divider('')
        self.root:action(T'Kick Godmode Bots', {}, T'This only applies to players who are not in an interior with godmode + attacking while invulnerable detection active', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) and players.user() ~= pid then
                    if not players.is_in_interior(pid) and players.is_godmode(pid) then
                        local proot = menu.player_root(pid)
                        local detections = proot:getChildren()[2]

                        if detections:isValid() then
                            for detections:getChildren() as detection do
                                if detection:isValid() then
                                    if tostring(detection.menu_name) == '313649715' then
                                        if players.get_host() == players.user() then
                                            local kick = proot:refByRelPath('Kick>Smart')
                                            if kick:isValid() then
                                                util.toast($'Kicking {players.get_name(pid)} for being a godmode bot')
                                                kick:trigger()
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
    end

    function CreateFakeNotifs()
        self.fake_notifications = self.root:list(T'Fake Notifications', {T'rofakenotif'}, T'Fake Notifications')
        self.fake_notifications:divider(T'Settings')
        self.fn_exclude_me = self.fake_notifications:toggle(T'Exclude Self', {T'notifsexcludeself'}, T'Exclude self from the fake notifications', function(state) 
            Settings:SetBool(Bits.ExcludeSelf, state)
        end, Settings:IsSet(Bits.ExcludeSelf))

        self.fn_exclude_friends = self.fake_notifications:toggle(T'Exclude Friends', {T'notifsexcludefriends'}, T'Exclude friends from the fake notifications', function(state) 
            Settings:SetBool(Bits.ExcludeFriends, state)
        end, Settings:IsSet(Bits.ExcludeFriends))
        self.fake_notifications:divider('')

        local mapping = {
            { name = T'Register CEO', func = S.RegisterCEO, args = nil },
            { name = T'Register MC', func = S.RegisterMC, args = nil },
            { name = T'Register VIP', func = S.RegisterVIP, args = nil },
            { name = T'Off Radar', func = S.OffRadar, args = nil },
            { name = T'Ghost Organisation', func = S.GhostOrg, args = nil },
            { name = T'Successfully Mugged', func = S.SuccessfullyMugged, args = { math.random(math.min_int, math.max_int) } },
            { name = T'Mugger Killed', func = S.MuggerKilled, args = nil },
            { name = T'Jammer Activated', func = S.JammerActivated, args = nil },
            { name = T'Quit Org', func = S.QuitOrg, args = { players.user() } },
            { name = T'Joined Org', func = S.JoinedOrg, args = { players.user() } },
            { name = T'Marked For Death', func = S.MarkedForDeath, args = { players.user() } }
        }

        for mapping as data do
            self.fake_notifications:toggle_loop(T(data.name), {}, '', function()
                if data.args ~= nil then
                    if data.name == T'Successfully Mugged' then data.args = { math.random(math.min_int, math.max_int) } end
                    self:SendNotif(data.func, table.unpack(data.args))
                else
                    self:SendNotif(data.func)
                end
                util.yield(100)
            end)
        end

        self.fake_notifications:divider('')

        for mapping as data do
            self.fake_notifications:action(T(data.name), {}, '', function()
                if data.args ~= nil then
                    if data.name == T'Successfully Mugged' then data.args = { math.random(math.min_int, math.max_int) } end
                    self:SendNotif(data.func, table.unpack(data.args))
                else
                    self:SendNotif(data.func)
                end
                util.yield(100)
            end)
        end

        mapped = nil
    end

    function CreateServices()
        self.services = self.root:list(T'Services', {T'roservices'}, T'Services')
        self.RequestBase = Globals.RequestBase:g()
        self.AmPiMenuBase = Globals.AmPiMenuBase:g()

        for ({
            { name = T'Request Nano Drone', func = self.RequestService, args = { self, T'NanoDrone' } },
            { name = T'Request RC Bandito', func = self.RequestService, args = { self, T'RCBandito' } },
            { name = T'Request RC Tank', func = self.RequestService, args = { self, T'RCTank' } },
            { name = T'Request MOC', func = self.RequestService, args = { self, T'MOC' } },
            { name = T'Request Avenger', func = self.RequestService, args = { self, T'Avenger' } },
            { name = T'Request Acid Lab', func = self.RequestService, args = { self, T'AcidLab' } },
            { name = T'Request Terrorbyte', func = self.RequestService, args = { self, T'Terrorbyte' } },
            { name = T'Request Dinghy', func = self.RequestService, args = { self, T'Dinghy' } },
            { name = T'Request Kosatka', func = self.RequestService, args = { self, T'Kosatka' } },
            { name = T'Request Sparrow', func = self.RequestService, args = { self, T'Sparrow' } },
            { name = T'Request Avisa', func = self.RequestService, args = { self, T'Avisa' } },
            { name = T'Request Ballistic Armor', func = self.RequestService, args = { self, T'BallisticArmor' } },
            { name = T'Request Ammo Drop', func = self.RequestService, args = { self, T'AmmoDrop' } },
            { name = T'Request Helicopter', func = self.RequestService, args = { self, T'Helicopter' } },
            { name = T'Request Delivery Bike', func = self.RequestService, args = { self, T'DeliveryBike' } },
            { name = T'Request Rat Bike', func = self.RequestService, args = { self, T'RatBike' } },
            { name = T'Request Avenger Thruster', func = self.RequestService, args = { self, T'AvengerThruster' } },
            { name = T'Request Airstrike', func = self.RequestService, args = { self, T'Airstrike' } },
            { name = T'Request Backup Heli', func = self.RequestService, args = { self, T'BackupHeli' } },
            { name = T'Request Bullshark Testosterone', func = self.RequestService, args = { self, T'BST' } },
            { name = T'Request Supplies', func = self.RequestService, args = { self, T'Supplies' } },
            { name = T'Source Motorcycle', func = self.RequestService, args = { self, T'SourceMotorcycle' } }
        }) as data do self.services:action(T(data.name), {T(data.name)}, '', function() data.func(table.unpack(data.args)) end) end

        self.services:divider('')

        for ({
            { name = T'Return Sparrow', func = S:Partial(self.ReturnSparrow, self) },
            { name = T'Return Avisa', func = S:Partial(self.ReturnAvisa, self) },
            { name = T'Return Avenger (Hangar)', func = S:Partial(self.ReturnAvenger, self, 'Hangar') },
            { name = T'Return Avenger (Facility)', func = S:Partial(self.ReturnAvenger, self, 'Facility') },
            { name = T'Return Avenger Thruster', func = S:Partial(self.ReturnAvengerThruster, self) },
            { name = T'Return Delivery Bike', func = S:Partial(self.ReturnDeliveryBike, self) },
            { name = T'Return Acid Lab', func = S:Partial(self.ReturnAcidLab, self) },
            { name = T'Return Kosatka', func = S:Partial(self.ReturnKosatka, self) },
            { name = T'Return Terrorbyte', func = S:Partial(self.ReturnTerrorbyte, self) },
            { name = T'Return MOC', func = S:Partial(self.ReturnMOC, self) },
            { name = T'Return Rat Bike', func = S:Partial(self.ReturnRatBike, self) }
        }) as data do self.services:action(data.name, {data.name}, '', data.func) end

        self.services:divider('')

        for ({
            { name = T'Locate Boat', func = || -> self:LesterLocate(LesterLocate.Boat), desc = T'Get Lester to locate a boat' },
            { name = T'Locate Heli', func = || -> self:LesterLocate(LesterLocate.Heli), desc = T'Get Lester to locate a helicopter' },
            { name = T'Lester Car', func = || -> self:LesterLocate(LesterLocate.Car), desc = T'Get Lester to locate a car' },
            { name = T'Locate Plane', func = || -> self:LesterLocate(LesterLocate.Plane), desc = T'Get Lester to locate a plane' }
        }) as data do self.services:action(data.name, {data.name}, data.desc, data.func) end

        self.services:divider('')

        self.pegasus = self.services:list(T'Pegasus', {T'ropegasus'}, T'Pegasus')
        self.ceo = self.services:list(T'CEO', {T'roceo'}, T'CEO')

        self.pegasus:text_input(T'Vehicle Model', {T'pegasusvehiclemodel'}, T'Enter the model name of the vehicle you want to request', function(model)
            self:RequestPegasusVehicle(model:joaat())
        end, 'adder')

        self.ceo:text_input(T'Vehicle Model', {T'ceovehiclemodel'}, T'Enter the model name of the vehicle you want to request', function(model)
            self:RequestCEOVehicle(model:joaat())
        end, 'adder')

        self.pegasus_models = self.pegasus:list(T'Vehicle Models', {T'vehiclemodels'}, T'Vehicle Models')
        self.ceo_models = self.ceo:list(T'Vehicle Models', {T'vehiclemodels'}, T'Vehicle Models')
        for VehModels as model do
            self.pegasus_models:action(model, {}, model, function()
                self:RequestPegasusVehicle(model:joaat())
            end)
            self.ceo_models:action(model, {}, model, function()
                self:RequestCEOVehicle(model:joaat())
            end)
        end

        self.services:divider('')

        self.services:text_input(T'Rename Acid Lab', {T'rorenameacidlab'}, T'Rename your Acid Lab, what else?', function(name)
            self:RenameAcidLab(name)
        end, self:GetAcidLabName())

        self.money_remover = self.services:list(T'Money Remover', {T'romoneyremover'}, T'Remove money')
        self.money_remover_amount = self.money_remover:text_input(T'Amount', {T'moneyremoveramount'}, T'Amount to remove', function(amount) end, '1')
    
        self.money_remover:action(T'Remove', {T'roremovemoney'}, T'Remove money', function()
            Network.RemoveMoney(tonumber(self.money_remover_amount.value))
        end)

        self.money_remover:toggle_loop(T'Looped Remove', {T'roloopedremove'}, T'Looped money removal', function()
            Network.RemoveMoney(tonumber(self.money_remover_amount.value))
        end)
    end

    function CreateOrganisation()
        self.organisation = self.root:list(T'Organisation', {T'roorganisation'}, T'Organisation')
        self.organisation:toggle_loop(T'Random Name', {T'rorandomname'}, T'Randomise your organisation name', function()
            Network.SetOrganisationName(S:RandomString(98))
        end)

        self.rename_org = self.organisation:text_input(T'Rename', {T'rorenameorg'}, T'', function(name)
            Network.SetOrganisationName(name)
        end, Network.GetOrganisationName())
    end

    function CreateBounty()
        self.bounty = self.root:list(T'Bounty', {T'robounty'}, T'Bounty')
        self.bounty:divider('Bounty Settings')
        self.bounty_amount = self.bounty:text_input(T'Bounty', {T'robountyamount'}, T'How much will someone get for killing the player?', function() end, '10000')
        self.bounty_reward = self.bounty:text_input(T'Reward', {T'robountyreward'}, T'How much will the player get for killing someone? this will override the amount that the player will get (if you set a $1 bounty on someone and set the reward to $10000 they will get $10000 instead of $1)', function() end, '10000')

        self.bounty:divider('Trolling')
        self.set_bounty = self.bounty:action(T'Set Bounty', {T'rosetbountyall'}, T'Set a bounty on the entire session', function()
            local amount = tonumber(self.bounty_amount.value)
            if amount < 0 or amount > 10000 or amount == nil then
                amount = 0
            end
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    Network.SetBounty(pid, amount, true)
                end
            end
        end)

        self.bounty:toggle_loop(T'Loop Bounty', {}, T'Loop set bounties on the entire session', function()
            self.set_bounty:trigger()
        end)

        self.bounty:toggle_loop(T'Set Bounty Reward', {T'rosetbountyall'}, T'Set the bounty reward for the entire session', function()
            local amount = tonumber(self.bounty_amount.value)
            if amount < 0 or amount > 10000 or amount == nil then
                amount = 0
            end
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    Network.SetBountyReward(pid, amount)
                end
            end
        end)

        self.bounty:toggle_loop(T'Max Bounty Reward', {T'romaxbountyreward'}, T'Set bounty reward to maximum for the entire session', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    Network.SetBountyReward(pid, 10000)
                end
            end
        end)
        
        self.bounty:divider('Friendly')
        self.bounty:action(T'Remove Bounty', {T'roremovebountyall'}, T'Remove bounty from entire session', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    Network.SetBounty(pid, 0, false)
                end
            end
        end)

        self.bounty:toggle_loop(T'Remove Bounty Reward', {T'roremovebountyrewardall'}, T'Remove bounty reward for the entire session', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    Network.SetBountyReward(pid, 0)
                end
            end
        end)

        self.bounty:divider('Other')
        self.bounty:toggle_loop(T'Display Bounties', {}, T'Display the bounties of the entire session', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    local bounty = Network.GetBounty(pid)
                    util.draw_debug_text(players.get_name(pid) .. ': ' .. bounty.amount .. ' | ' .. ((Network.IsBountyModded(bounty.amount) and bounty.has_bounty) ? 'Modded' : 'Normal'))
                end
            end
        end)
    end

    function CreateSpoofing()
        self.spoofing = self.root:list(T'Spoofing', {T'rospoofing'}, T'Spoofing')
        self.spoofing:action(T'Spoof Special Property Ownership', {}, T'Spoof ownership of special properties like Kosatka, Terrorbyte etc, this allows you to invite players to someone elses kosatka, terrorbyte', function()
            Network.SpoofSpecialPropertyOwner(players.user())
        end)

        self.hide_from_player_list = self.spoofing:toggle_loop(T'Hide From Player List', {}, T'Hides you from the player list', function()
            Network.HideFromPlayerList(true)
        end, function()
            Network.HideFromPlayerList(false)
        end)

        self.spoofing:divider('')
        self.stats = self.spoofing:list(T'Stat Spoofing', {T'rostats'}, T'Stats')
        self.stat_total_money = self.stats:list(T'Total Money', {}, T'Spoof your total money')
        self.stat_total_wallet = self.stats:list(T'Wallet Money', {}, T'Spoof your wallet money')
        self.stat_rp = self.stats:list(T'RP', {}, T'Spoof your RP')
        self.stat_rank = self.stats:list(T'Rank', {}, T'Spoof your rank')
        self.stat_playerkills = self.stats:list(T'Player Kills', {}, T'Spoof your player kills')
        self.stat_playerdeaths = self.stats:list(T'Player Deaths', {}, T'Spoof your player deaths')
        self.stat_kd = self.stats:list(T'K/D', {}, T'Spoof your K/D')
        self.stat_is_badsport = self.stats:list(T'Is Bad Sport', {}, T'Spoof your bad sport status')
        self.stat_is_cheater = self.stats:list(T'Is Cheater', {}, T'Spoof your cheater status')
        self.stat_spoof_job_points = self.stats:list(T'Job Points', {}, T'Spoof your job points')

        self.stat_total_money:toggle_loop(T'Enable', {}, T'Enable total money spoofing', function()
            Network.SpoofTotalMoney(tonumber(self.total_money.value))
        end)

        self.total_money = self.stat_total_money:text_input(T'Total Money', {T'rosstotalmoney'}, T'Enter the total money you want to spoof', function() end, Network.StatsGetTotalMoney())

        self.stat_total_wallet:toggle_loop(T'Enable', {}, T'Enable wallet money spoofing', function()
            Network.SpoofWallet(tonumber(self.total_wallet.value))
        end)

        self.total_wallet = self.stat_total_wallet:text_input(T'Wallet Money', {T'rosstotalwallet'}, T'Enter the wallet money you want to spoof', function() end, Network.StatsGetWallet())

        self.stat_rp:toggle_loop(T'Enable', {}, T'Enable RP spoofing', function()
            Network.SpoofRP(tonumber(self.rp.value))
        end)

        self.rp = self.stat_rp:text_input(T'RP', {T'rossrp'}, T'Enter the RP you want to spoof', function() end, Network.StatsGetRP())

        self.stat_rank:toggle_loop(T'Enable', {}, T'Enable rank spoofing', function()
            Network.SpoofRank(tonumber(self.rank.value))
        end)

        self.rank = self.stat_rank:text_input(T'Rank', {T'rossrank'}, T'Enter the rank you want to spoof', function() end, Network.StatsGetRank())

        self.stat_playerkills:toggle_loop(T'Enable', {}, T'Enable player kills spoofing', function()
            Network.SpoofKills(tonumber(self.playerkills.value))
        end)

        self.playerkills = self.stat_playerkills:text_input(T'Player Kills', {T'rossplayerkills'}, T'Enter the player kills you want to spoof', function() end, Network.StatsGetKills())

        self.stat_playerdeaths:toggle_loop(T'Enable', {}, T'Enable player deaths spoofing', function()
            Network.SpoofDeaths(tonumber(self.playerdeaths.value))
        end)

        self.playerdeaths = self.stat_playerdeaths:text_input(T'Player Deaths', {T'rossplayerdeaths'}, T'Enter the player deaths you want to spoof', function() end, Network.StatsGetDeaths())

        self.stat_kd:toggle_loop(T'Enable', {}, T'Enable K/D spoofing', function()
            Network.SpoofKD(tonumber(self.kd.value))
        end)

        self.kd = self.stat_kd:text_input(T'K/D', {T'rosskd'}, T'Enter the K/D you want to spoof', function() end, Network.StatsGetKD())

        self.stat_is_badsport:toggle_loop(T'Enable', {}, T'Enable bad sport spoofing', function()
            Network.SpoofIsBadSport(true)
        end, function()
            Network.SpoofIsBadSport(false)
        end)

        self.stat_is_cheater:toggle_loop(T'Enable', {}, T'Enable cheater spoofing', function()
            Network.SpoofIsCheater(true)
        end, function()
            Network.SpoofIsCheater(false)
        end)

        self.stat_spoof_job_points:text_input(T'Job Points', {T'rossjobpoints'}, T'Enter the job points you want to spoof', function(value) 
            Network.SpoofJobPoints(tonumber(value))
        end, Network.StatsGetJobPoints())

        self:UpdateInteriorIndex()
        self.interior_spoofing = self.spoofing:list(T'Interior Spoofing', {T'rointeriorspoofing'}, T'Interior Spoofing', function()
            self:UpdateInteriorIndex()
            self.interior_choice.value = self.interior_index
        end)
        self.interior_choice = self.interior_spoofing:list_select(T'Interior', {T'interiorchoice'}, T'The interior to spoof to', self.properties, self.interior_index, function(_) end)
        self.interior_spoofing:divider('')
        self.interior_spoofing:action(T'Spoof', {T'rospoofinterior'}, T'Spoof to the selected interior', function()
            Network.SetInterior(S.PropertyIds[self.properties_data[self.interior_choice.value]])
        end)

        self.interior_spoofing:toggle_loop(T'Spoof', {T'roloopinteriorspoofing'}, T'Spoof to the selected interior (looped)', function()
            Network.SetInterior(S.PropertyIds[self.properties_data[self.interior_choice.value]])
        end)

        self.interior_spoofing:toggle_loop(T'Random Spoof', {T'roloopinteriorspoofingrand'}, T'Spoof to random interiors constantly', function()
            local rand = math.random(1, #self.properties_data)
            Network.SetInterior(S.PropertyIds[self.properties_data[rand]])
            util.yield(1000)
        end)

        self.blip_spoofing = self.spoofing:list(T'Blip Spoofing', {T'roblipspoofing'}, T'Blip Spoofing')
        self.blip_x = self.blip_spoofing:text_input(T'X', {T'roblipx'}, T'X coordinate of the blip', function() end, '0')
        self.blip_y = self.blip_spoofing:text_input(T'Y', {T'roblipy'}, T'Y coordinate of the blip', function() end, '0')
        self.blip_z = self.blip_spoofing:text_input(T'Z', {T'roblipz'}, T'Z coordinate of the blip', function() end, '0')
        self.blip_spoofing:divider('')

        self.blip_spoofing:toggle(T'Ballistic Armor Blip', {T'rospoofarmorblip'}, T'Spoof your blip as ballistic armor', function(state)
            Network.ToggleBallisticArmorBlip(state)
        end)

        self.blip_spoofing:toggle_loop(T'Bounty Blip', {T'rospoofbountyblip'}, T'Spoof your blip as a bounty', function()
            Network.SetBounty(players.user(), -1, true)
        end, function()
            Network.SetBounty(players.user(), 0, false)
        end)

        self.blip_spoofing:toggle_loop(T'Spoof', {T'rospoofblip'}, T'Spoof the blip to the selected coordinates', function()
            local x, y, z = tonumber(self.blip_x.value), tonumber(self.blip_y.value), tonumber(self.blip_z.value)
            if x == nil or y == nil or z == nil then
                x, y, z = 0, 0, 0
            end
            Network.SpoofInteriorState1(true)
            Network.SpoofBlipCoords(x, y, z)
        end, function()
            local coords = players.get_position(players.user())
            Network.SpoofInteriorState1(false)
            Network.SpoofBlipCoords(coords.x, coords.y, coords.z)
        end)
    end

    function CreateGhosting()
        self.ghosting = self.root:list(T'Ghosting', {T'roghosting'}, T'Ghosting')
        self.ghosting:toggle(T'All Players', {}, T'Ghost all players in the session', function(state)
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) and pid ~= players.user() then
                    network.set_remote_player_as_ghost(pid, state)
                end
            end
        end)
        self.ghosting:divider('')

        function H.GhostingLoop(pid, root)
            local name = players.get_name(pid)
            if pid ~= players.user() then
                local ref = self.ghosting:refByRelPath(name)
                if not ref:isValid() then
                    self.ghosting:toggle(name, {T'roghost' .. name}, T'Ghost a player', function(state)
                        network.set_remote_player_as_ghost(pid, state)
                    end)
                end
            end
        end

        function H.GhostingRemovePlayer(pid, name)
            if pid ~= players.user() then
                local ref = self.ghosting:refByRelPath(name)
                if ref:isValid() then
                    ref:delete()
                end
            end
        end
    end

    function CreateOther()
        self.other = self.root:list(T'Other', {T'roother'}, T'Other')
        self.other:action(T'Toast The Beast', {}, T'Toast the player who is the beast within the hunt the beast event', function()
            local beast = Network.GetTheBeast()
            if beast ~= -1 then
                Notifications.Show($'{players.get_name(beast)} is the beast', 'MrRobot', '', Notifications.HUD_COLOUR_BLACK)
            else
                Notifications.Show('No player is the beast', 'MrRobot', '', Notifications.HUD_COLOUR_BLACK)
            end
        end)

        self.other:action(T'Quick Bail', {}, T'Force yourself to bail from the session', function()
            memory.write_int(Globals.QuickBail:g(), 5)
        end)
    end

    function CreateCasino()
        self.casino = self.root:list(T'Casino', {T'rocasino'}, T'Casino')
        self.casino:action(T'Bypass Casino Win/Lose Limit', {}, T'Bypass the casino win/lose limit', function()
            stats.stat_set_int(('MPPLY_CASINO_CHIPS_WON_GD'):joaat(), 0)
        end)
        self.casino:divider('')
        self.blackjack = self.casino:list(T'Blackjack', {T'rblackjack'}, T'Blackjack')
        self.blackjack:toggle_loop(T'Show Dealer Cards', {}, T'Show the cards of the dealer (it also shows your cards)', function()
            util.spoof_script(G.BJS, function()
                local dealer = memory.script_local(table.unpack(Globals.BlackjackDealerCards))
                local player = memory.script_local(table.unpack(Globals.BlackjackPlayerCards))
                local dealer_cards, player_cards = memory.read_byte(dealer), memory.read_byte(player)
                util.draw_debug_text('Dealer: ' .. dealer_cards .. ' | Player: ' .. player_cards)
            end)
        end)

        self.blackjack:toggle_loop(T'Always Max Bet', {}, T'Always set your bet to max (bypasses limits on lower tables)', function()
            util.spoof_script(G.BJS, function()
                local bet = memory.script_local(table.unpack(Globals.BlackjackBetAmount))
                memory.write_int(bet, 55000)
            end)
        end)
        self.blackjack:divider('')

        self.bet_amount = self.blackjack:text_input(T'Bet Amount', {T'blackjackbetamount'}, T'Set the bet amount', function(amount) end, '1000')
        self.blackjack:toggle_loop(T'Set Bet', {T'blackjacksetbet'}, T'Set the bet amount', function()
            util.spoof_script(G.BJS, function()
                local bet = memory.script_local(table.unpack(Globals.BlackjackBet))
                local amount = tonumber(self.bet_amount.value)
                if amount < 0 then amount = 1000 end
                if amount > 1000000 then amount = 1000000 end
                memory.write_int(bet, amount)
            end)
        end)

        self.blackjack:toggle_loop(T'Display Current Bet', {T'blackjackdisplaybet'}, T'Display the current bet amount', function()
            util.spoof_script(G.BJS, function()
                local bet = memory.script_local(table.unpack(Globals.BlackjackBet))
                util.draw_debug_text('Bet: ' .. memory.read_int(bet))
            end)
        end)
    end

    function UpdateInteriorIndex()
        local current_interior = Network.GetInterior()
        self.interior_index = 1
        for i = 1, #self.properties do
            if S.PropertyIds[self.properties[i]] == current_interior then
                self.interior_index = i
                break
            end
        end
    end

    function CreateStoreHoldUps()
        self.store_holdups = self.root:list(T'Store Holdups', {T'rostoreholdups'}, T'Store Holdups')

        self.force_robbery = self.store_holdups:action(T'Force Robbery', {}, T'Force a robbery when you are inside of a store', function()
            local store = memory.script_local(table.unpack(Globals.HoldUpForceRobbery))
            if store ~= 0 then
                memory.write_int(store, memory.bits:set(memory.read_int(store), memory.bits.masks.HoldUpForceRobbery))
            end
        end)

        self.instant_finish_robbery = self.store_holdups:action(T'Instant Finish Robbery', {}, T'Instantly finish a robbery when you are inside of a store', function()
            local store = memory.script_local(table.unpack(Globals.HoldUpForceRobbery))
            local scene = memory.script_local(table.unpack(Globals.HoldUpRobberySceneId))
            if store ~= 0 and scene ~= 0 then
                memory.write_int(store, memory.bits:set(memory.read_int(store), memory.bits.masks.HoldUpForceRobbery))
                local scene_id = memory.read_int(scene)
                repeat
                    util.yield_once()
                    scene_id = memory.read_int(scene)
                until scene_id ~= -1
                repeat
                    util.yield_once()
                until ped.is_synchronized_scene_running(scene_id)
                ped.set_synchronized_scene_phase(scene_id, 100.0)
            end
        end)
    end

    function CreateTaxiService()
        self.taxi = self.root:list(T'Taxi Service', {T'rtaxi'}, T'Taxi Service')

        self.taxi:action(T'Instant Quit', {}, T'Instantly quit the taxi service', function()
            local quit = memory.script_local(table.unpack(Globals.TaxiServiceInstantQuit))
            if quit ~= 0 then
                memory.write_int(quit, 2)
            end
        end)

        self.taxi:text_input(T'Fare', {T'taxiservicefare'}, T'Set the fare for the taxi service', function(amount)
            local fare = memory.script_local(table.unpack(Globals.TaxiServiceFare))
            if fare ~= 0 then
                memory.write_int(fare, tonumber(amount))
            end
        end)

        self.taxi:text_input(T'Tip', {T'taxiservicetip'}, T'Set the tip for the taxi service', function(amount)
            local tip = memory.script_local(table.unpack(Globals.TaxiServiceTip))
            if tip ~= 0 then
                memory.write_int(tip, tonumber(amount))
            end
        end)

        self.taxi:toggle_loop(T'Disable Customer Salt', {}, T'Prevent the customer from getting mad at you and decreasing the tip, crashing will still cause the customer to get mad at you though!', function()
            local salt = memory.script_local(table.unpack(Globals.TaxiServiceSaltTimerActive))
            if salt ~= 0 then
                memory.write_int(salt, 0)
            end
        end)

        self.taxi:toggle_loop(T'Remove Fare', {}, T'Remove the fare', function()
            local fare = memory.script_local(table.unpack(Globals.TaxiServiceFare))
            if fare ~= 0 then
                memory.write_int(fare, 0)
            end
        end)

        self.taxi:toggle_loop(T'Remove Tip', {}, T'Remove the tip', function()
            local tip = memory.script_local(table.unpack(Globals.TaxiServiceTip))
            if tip ~= 0 then
                memory.write_int(tip, 0)
            end
        end)

        self.taxi:toggle_loop(T'Max Tip', {}, T'Set the tip to the maximum value', function()
            local fare = memory.script_local(table.unpack(Globals.TaxiServiceFare))
            local tip = memory.script_local(table.unpack(Globals.TaxiServiceTip))
            if fare ~= 0 and tip ~= 0 then
                memory.write_int(fare, 0)
                memory.write_int(tip, 15000)
            end
        end)
    end

    function CreateATM()
        self.atm = self.root:list(T'ATM', {T'roatm'}, T'ATM')
        self.atm:action(T'Deposit', {T'rtdepall'}, T'Deposits all money into your bank', || -> Network.TransferToBank())
        self.atm:divider('')
        self.atm:toggle_loop(T'Auto Deposit', {T'rtautodepall'}, T'Automatically deposit all money in your wallet to bank', || -> Network.TransferToBank())
        self.atm:text_input(T'Deposit Amount', {T'rtdepamount'}, T'Amount of money to deposit into your bank from wallet', |amount| -> Network.TransferToBank(tonumber(amount)))
    end

    function CreateCargo()
        self.crates_amount = nil
        local cargo_amount = 50
        local crate_type = 0
        self.cargo = self.root:list(T'Cargo', {T'rocargo'}, T'Cargo')

        self.cargo:list_select(T'Crate Type', {T'rocargotype'}, T'The type of crate to source', {
            {1, 'Animal Materials'},
            {2, 'Art & Antiques'},
            {3, 'Chemicals'},
            {4, 'Counterfeit Goods'},
            {5, 'Jewelry & Gemstones'},
            {6, 'Medical Supplies'},
            {7, 'Narcotics'},
            {8, 'Tobacco & Alcohol'},
            {9, 'Cargo'}
        }, 1, function(index)
            crate_type = index - 1
        end)

        self.cargo:text_input(T'Crates', {T'rocargoamount'}, T'Amount of cargo to source', function(amount) 
            cargo_amount = amount
        end, '50')
        self.cargo:toggle_loop(T'Display Crates', {T'rodisplaycrates'}, T'Display the amount of crates in your hangar', function()
            local total_crates = Globals.HangarTotalCargo:g()
            util.draw_debug_text($'Crates: {memory.read_int(total_crates)}')
        end)

        self.cargo:toggle_loop(T'Remove Sell Cooldown', {T'roremovesellcooldown'}, T'Remove the cooldown for selling cargo', function()
            local cooldown = Globals.HangarCargoSellCooldown:g()
            if cooldown ~= 0 then
                memory.write_int(cooldown, 0)
            end
        end)
        self.cargo:divider('')

        self.cargo:action(T'Instant Source', {}, T'Instantly source cargo for air freight', function()
            local source = Globals.InstantSourceHangarCargo:g()
            local total_crates = Globals.HangarCratesToSource:g()
            local cargo_type = Globals.HangarCrateType:g()
            local total_cargo = Globals.HangarTotalCargo:g()

            if (memory.read_int(total_cargo) < 50) then
                memory.write_int(total_crates, cargo_amount)
                memory.write_int(cargo_type, crate_type)
                memory.write_int(source, memory.bits:toggle(memory.read_int(source), 1 << 9))
                util.yield(800)
                memory.write_int(source, memory.bits:toggle(memory.read_int(source), 1 << 9))
            else
                Notifications.Show('Your hangar is full, unable to source more cargo', 'Air Freight', '', Notifications.HUD_COLOUR_REDDARK)
            end
        end)

        self.cargo:action(T'Launch App', {T'roappsmugler'}, T'Remotely open air freight internt application', function()
            S:StartNewScript(G.AS)
        end)
    end

    function CreateMoney()
        self.money = self.root:list(T'Money (RISKY)', {T'romoney'}, T'Money')
        self.money.visible = false
        table.insert(S.RiskyRefs, self.money)

        local cayo = self.money:list(T'Cayo Perico', {}, T'Money from cayo perico heist')
        local casino = self.money:list(T'Casino', {}, T'Money from casino heist')

        cayo:action(T'Maximum (2.55M)', {}, T'Get the maximum amount of money that you can get from the heist', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_ISLAND_HEIST_FINALE'), 2550000)
        end)

        cayo:action(T'Legit (900K - 1.9M)', {}, T'Get a reasonable amount of money from the heist that seems more legit', function()
            local choices = {900000, 1000000, 1100000, 1300000, 1900000}
            local choice = choices[math.random(#choices)]
            local amount = choice - (choice * 0.12000000000000001)
            S:TriggerTransaction(util.joaat('SERVICE_EARN_ISLAND_HEIST_FINALE'), amount)
        end)

        casino:action(T'Maximum (3.55M)', {}, T'Get the maximum amount of money that you can get from the heist', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_CASINO_HEIST_FINALE'), 3550000)
        end)

        casino:toggle_loop(T'Member Bonus Loop (5K Chips)', {}, '', function()
            memory.write_byte(Globals.CasinoChipsMemBonus:g(), 1)
            util.yield_once()    
        end)

        self.money:divider('')
        self.money:action(T'Criminal Mastermind (10M)', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_JOB_BONUS_CRIMINAL_MASTERMIND'), 10000000)
        end)

        self.money:action(T'180K', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_JOBS'), 180000)
        end)

        self.money:action(T'200K', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_COLLECTABLE_COMPLETED_COLLECTION'), 200000)
        end)

        self.money:action(T'680K', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_BETTING'), 680000)
        end)

        self.money:action(T'25K', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_AMBIENT_JOB_SMUGGLER_PLANE'), 25000)
        end)
        
        self.money:action(T'Salvage Yard (1.5M)', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_SALVAGE_YARD_SELL_VEH'), 1500000)
        end)

        self.money:divider('')

        self.money:toggle_loop(T'180K Loop', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_JOBS'), 180000)
        end)

        self.money:toggle_loop(T'200K Loop', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_COLLECTABLE_COMPLETED_COLLECTION'), 200000)
        end)

        self.money:toggle_loop(T'680K Loop', {}, T'', function()
            S:TriggerTransaction(util.joaat('SERVICE_EARN_BETTING'), 680000)
        end)
    end

    function CreateYeti()
        self.yeti = self.root:list(T'Yeti', {T'royeti'}, T'Yeti')
        self.yeti:toggle(T'Event State', {}, T'Enable/disable yeti event', function(state)
            memory.write_int(Globals.YetiEventEnable:g(), state ? 1 : 0)
        end, memory.read_int(Globals.YetiEventEnable:g()) == 1)

        self.yeti:toggle(T'Big RP', {}, T'Increase RP so you get a total of 450,000 from investigate all clues button below', function(state)
            memory.write_float(memory.script_global(262145 + 1), state ? 90 : 1)
        end)

        self.yeti:toggle(T'Disable RP', {}, T'Disable RP so you don\'t get any from investigating all clues', function(state)
            memory.write_float(memory.script_global(262145 + 1), state ? 0 : 1)
        end)

        self.yeti:action(T'Investigate All Clues', {}, T'Investigate all the clues instantly', function()
            local addr = memory.script_local(table.unpack(Globals.YetiCluesBitfield))
            if addr ~= nil then
                local bitfield = pluto_new Bitfield(memory.read_int(addr), addr)
                memory.write_int(Globals.YetiEventEnable:g(), 1)
                memory.write_int(Globals.YetiClueReward:g(), 0)

                bitfield:Set(0x203)
                local timeout = os.time() + 2
                util.create_tick_handler(function()
                    memory.write_int(memory.script_local(table.unpack(Globals.YetiCluesCollected)), 5)
                    if os.time() > timeout then
                        return false
                    end
                end)

                for i = 0, 5 do
                    bitfield:Set(1 << 2)
                    util.yield(50)
                    bitfield:Clear(1 << 2)
                    util.yield(200)
                end

                memory.write_int(Globals.YetiClueReward:g(), 10000)
            end
        end)
        self.yeti:divider('')

        self.yeti:action(T'Teleport To Bloodied Tent', {}, '', function()
            local localplayer = players.localplayer()
            localplayer:set_entity_coords_no_offset(-1562.69, 4699.04, 50.426, false, false, false)
        end)

        self.yeti:action(T'Teleport To Torn Shirt', {}, '', function()
            local localplayer = players.localplayer()
            localplayer:set_entity_coords_no_offset(-1359.869, 4733.429, 46.919, false, false, false)
        end)

        self.yeti:action(T'Teleport To Deer', {}, '', function()
            local localplayer = players.localplayer()
            localplayer:set_entity_coords_no_offset(-1715.398, 4501.203, 0.096, false, false, false)
        end)

        self.yeti:action(T'Teleport To Body Parts', {}, '', function()
            local localplayer = players.localplayer()
            localplayer:set_entity_coords_no_offset(-1567.8599, 4478.6294, 20.928696, false, false, false)
        end)

        self.yeti:action(T'Teleport To Chiliad Wilderness', {}, '', function()
            local localplayer = players.localplayer()
            localplayer:set_entity_coords_no_offset(-1345.828, 4838.062, 137.522, false, false, false)
        end)
    end

    function CreateTutorialSessions()
        self.tut_sessions = self.root:list(T'Tutorial Sessions', {T'rotutsession'}, T'Tutorial Sessions')
        self.tut_sessions:toggle(T'Create Safe Session', {}, T'Create a tutorial session that other players cannot join giving you a safe space to go afk without being killed', function(state)
            if not SCRIPT_CAN_CONTINUE then return end
            if state then
                network.network_start_solo_tutorial_session()
            else
                network.network_end_tutorial_session()
            end
        end, network.network_is_in_tutorial_session())
    end

    function CreateBlameKill()
        self.bk_plist = { { 1, 'None' } }
        self.blame_kill = self.root:list(T'Blame Kill', {T'roblamekill'}, T'Blame Kill')
        self.victim = self.blame_kill:list_select(T'Victim', {T'bkvictim'}, T'The player that will be killed', self.bk_plist, 1, function() end)
        self.killer = self.blame_kill:list_select(T'Killer', {T'bkkiller'}, T'The player that will be blamed for the kill', self.bk_plist, 1, function() end)
        self.auto_spect = self.blame_kill:toggle(T'Auto Spectate', {}, '', function(state) end, true)

        self.blame_kill:divider('')
        self.blame_kill:action(T'Vehicle Kill', {}, '', function()
            local victim_data = self.bk_plist[self.victim.value]
            local killer_data = self.bk_plist[self.killer.value]
            
            if victim_data == nil or killer_data == nil then
                return
            end

            local victim_name = victim_data[2]
            local killer_name = killer_data[2]

            local victim = players.get_pid_from_name(victim_name)
            local killer = players.get_pid_from_name(killer_name)

            if victim ~= -1 and killer ~= -1 then
                local victim_ped = player.get_player_ped(victim)
                local veh = ped.get_vehicle_ped_is_using(victim_ped)
                local spect = menu.player_root(victim):refByRelPath('Spectate>Nuts Method')

                if veh ~= 0 then
                    return util.toast($'{players.get_name(victim)} is in a vehicle!')
                end

                if spect:isValid() then
                    spect.value = self.auto_spect.value
                end

                S:VehicleBlameKill(victim, killer, ('khanjali'):joaat(), true, function()
                    if spect:isValid() then
                        spect.value = false
                    end
                end)
            end
        end)

        self.blame_kill:action(T'Stop Spectating', {}, '', function()
            local spectate = menu.player_root(players.user()):refByRelPath('Spectate>Nuts Method')
            if spectate:isValid() then
                spectate.value = true
                spectate.value = false
            end
        end)

        self.blame_kill:action(T'Stop Blame Kill', {}, '', function()
            S.bk_stopflag = true
        end)

        self.esp = self.root:list(T'ESP', {}, T'Player ESP')
        self.esp:toggle_loop(T'Bone ESP', {}, T'Enable bone ESP for this player', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    if self.esp_exclude_self and pid == players.user() then
                        goto continue
                    elseif self.esp_exclude_friends and S:IsFriend(pid) then
                        goto continue
                    else
                        S:DrawBoneESP(player.get_player_ped(pid), self.esp_colours.bone)
                    end
                    ::continue::
                end
            end
        end)

        self.esp:toggle_loop(T'Box ESP', {}, T'Enable box ESP for this player', function()
            local red = math.floor(self.esp_colours.box.r * 255)
            local green = math.floor(self.esp_colours.box.g * 255)
            local blue = math.floor(self.esp_colours.box.b * 255)
            local alpha = math.floor(self.esp_colours.box.a * 255)
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    if self.esp_exclude_self and pid == players.user() then
                        goto continue
                    elseif self.esp_exclude_friends and S:IsFriend(pid) then
                        goto continue
                    else
                        S:DrawDXBoundingBox(player.get_player_ped(pid), alpha | (red << 24) | (green << 16) | (blue << 8))
                    end
                    ::continue::
                end
            end
        end)

        self.esp:toggle_loop(T'Name ESP', {}, T'Enable name ESP for this player', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    if self.esp_exclude_self and pid == players.user() then
                        goto continue
                    elseif self.esp_exclude_friends and S:IsFriend(pid) then
                        goto continue
                    else
                        S:DrawNameESP(player.get_player_ped(pid), players.get_name(pid), self.esp_colours.name)
                    end
                    ::continue::
                end
            end
        end)

        self.esp:toggle_loop(T'Health Bar ESP', {}, T'Enable health bar ESP for this player', function()
            for pid = 0, players.max_players do
                if S:PlayerExists(pid) then
                    if self.esp_exclude_self and pid == players.user() then
                        goto continue
                    elseif self.esp_exclude_friends and S:IsFriend(pid) then
                        goto continue
                    else
                        S:DrawHealthBar(player.get_player_ped(pid))
                    end
                    ::continue::
                end
            end
        end)

        self.esp:divider('')
        self.esp:colour(T'Bone Colour', {}, T'The colour of the bones', self.esp_colours.bone, false, function(colour) self.esp_colours.bone = colour end)
        self.esp:colour(T'Box Colour', {}, T'The colour of the box', self.esp_colours.box, false, function(colour) self.esp_colours.box = colour end)
        self.esp:colour(T'Name Colour', {}, T'The colour of the name', self.esp_colours.name, false, function(colour) self.esp_colours.name = colour end)

        self.esp:divider('')
        self.exclude_self_toggle = self.esp:toggle(T'Exclude Yourself', {}, T'Exclude yourself from the ESP', function(state)
            self.esp_exclude_self = state
        end)
        self.exclude_self_toggle.value = true
        

        self.esp:toggle(T'Exclude Friends', {}, T'Exclude friends from the ESP', function(state)
            self.esp_exclude_friends = state
        end)

        self.invites = self.root:list(T'Invites', {}, T'Quickly invite players to your session using a command', nil, nil)
        if not self.updating.quick_invites then
            self:UpdateQuickInvites()
            self.updating.quick_invites = true
            self.invite_command = menu.ref_by_command_name('ridinvite')
        end
    end

    function BlameKillAdd(pid, root)
        local name <const> = players.get_name(pid)
        self.bk_plist[#self.bk_plist + 1] = { #self.bk_plist + 1, name }
        self.victim:setListActionOptions(self.bk_plist)
        self.killer:setListActionOptions(self.bk_plist)
    end

    function BlameKillRemove(pid, name)
        for i = 1, #self.bk_plist do
            local tbl = self.bk_plist[i]
            if type(tbl) == 'table' then
                if tbl[2] == name then
                    table.remove(self.bk_plist, i)
                    self.victim.value = 1
                    self.killer.value = 1
                end
            end
        end
        self.victim:setListActionOptions(self.bk_plist)
        self.killer:setListActionOptions(self.bk_plist)
    end

    function UpdateQuickInvites()
        util.create_tick_handler(function()
            if filesystem.exists(filesystem.script_root() .. '/config/quick_invites.json') then
                local file <close> = assert(io.open(filesystem.script_root() .. '/config/quick_invites.json', 'r'))
                local data = file:read('*all')
                file:close()
                local invites = soup.json.decode(data)
                if invites ~= nil then
                    for k, v in pairs(invites) do
                        local ref = self.invites:refByRelPath(k)
                        if not ref:isValid() then
                            self.invites:action(k, {$'inv{v[2]}'}, T'Invite your friend', function()
                                if self.invite_command:isValid() then
                                    for pid = 0, players.max_players do
                                        if S:PlayerExists(pid) then
                                            if tostring(players.get_rockstar_id(pid)):hash() == v[1] then
                                                util.toast($'They are already in the session you stupid cunt')
                                                goto not_invite
                                            end
                                        end
                                    end

                                    self.invite_command:trigger(v[1])
                                end

                                ::not_invite::
                            end)
                        end
                    end
                end
            end

            util.yield(5000)
        end)
    end

    function ReturnSparrow()
        local stats = Globals.KosatkaStatsBase:g()
        local value = memory.read_byte(stats)
        value = memory.bits:clear(value, KosatkaStats.ReturnSparrow)
        memory.write_byte(stats, value)
    end

    function ReturnAvisa()
        local stats = Globals.KosatkaStatsBase:g()
        local value = memory.read_byte(stats)
        value = memory.bits:clear(value, KosatkaStats.ReturnAvisa)
        memory.write_byte(stats, value) 
    end

    function ReturnAvenger(location)
        local stats = Globals.AvengerStatsBase:g()
        local stats1 = stats - (4 << 3)
        local value = memory.read_int(stats)
        memory.write_int(stats, memory.bits:set(memory.read_int(stats), 1 << 20))
        util.yield(10)
        memory.write_int(stats, memory.bits:clear(memory.read_int(stats), 1 << 20))
        if location == 'Hangar' then
            memory.write_int(stats1, memory.bits:clear(memory.read_int(stats1), 1 << 6))
        elseif location == 'Facility' then
            memory.write_int(stats1, memory.bits:set(memory.read_int(stats1), 1 << 6))
        end
        memory.write_int(stats1, memory.bits:set(memory.read_int(stats), 1 << 3))
        memory.write_int(stats, memory.bits:set(memory.read_int(stats), 1 << 16))
        util.yield(10)
        memory.write_int(stats1, memory.bits:clear(memory.read_int(stats), 1 << 3))
    end

    function ReturnAvengerThruster()
        local blip = hud.get_first_blip_info_id(597)
        if blip ~= 0 then
            local entity = hud.get_blip_info_id_entity_index(blip)
            if entity ~= 0 then
                entities.delete_by_handle(entity)
            end
        end
    end

    function ReturnDeliveryBike()
        local blip = hud.get_first_blip_info_id(348)
        if blip ~= 0 then
            local entity = hud.get_blip_info_id_entity_index(blip)
            if entity ~= 0 then
                local stats = Globals.AcidLabStatsBase:g()
                memory.write_short(stats, memory.bits:clear(memory.read_short(stats), 1 << 6))
                memory.write_short(stats, memory.bits:set(memory.read_short(stats), 0x300))
                entities.delete_by_handle(entity)
            end
        end
    end

    function ReturnAcidLab()
        local blip = hud.get_first_blip_info_id(840)
        if blip ~= 0 then
            local entity = hud.get_blip_info_id_entity_index(blip)
            if entity ~= 0 then
                local stats = Globals.AcidLabStatsBase:g()
                local stats1 = stats - 0x8
                memory.write_int(stats1, memory.bits:set(memory.read_int(stats), 1 << 26))
                memory.write_int(stats, memory.bits:clear(memory.read_int(stats), 1 << 0))
                memory.write_int(stats, memory.bits:set(memory.read_int(stats1), 0x100002))
                entities.delete_by_handle(entity)
            end
        end
    end

    function ReturnKosatka()
        local kosatka = Globals.ReturnKosatka:g()
        local kosatka1 = kosatka + 0x8
        memory.write_byte(kosatka, 2)
        memory.write_byte(kosatka1, 17)
    end

    function ReturnTerrorbyte()
        local blip = hud.get_first_blip_info_id(632)
        if blip ~= 0 then
            local entity = hud.get_blip_info_id_entity_index(blip)
            if entity ~= 0 then
                local stats = Globals.TerrorbyteStatsBase:g()
                memory.write_int(stats, memory.bits:set(memory.read_int(stats), 0x18000090))
                memory.write_int(stats, memory.bits:clear(memory.read_int(stats), 1 << 11))
                entities.delete_by_handle(entity)
            end
        end
    end

    function ReturnMOC()
        -- credit to Acjoker for helping with figuring out how to return the MOC
        local blip = hud.get_first_blip_info_id(564)
        if blip ~= 0 then
            local entity = hud.get_blip_info_id_entity_index(blip)
            if entity ~= 0 then
                local stats = Globals.MOCStatsBase:g()
                local stats1 = stats + 0x8
                memory.write_int(stats, memory.bits:set(memory.read_int(stats), 0x100040))
                memory.write_int(stats, memory.bits:clear(memory.read_int(stats), 1 << 5))
                memory.write_int(stats1, memory.bits:clear(memory.read_int(stats), 0x2100001))
                memory.write_int(stats1, memory.bits:clear(memory.read_int(stats), 1 << 8))
            end
        end
    end

    function ReturnRatBike()
        local  blip = hud.get_first_blip_info_id(348)
        if blip ~= 0 then
            local entity = hud.get_blip_info_id_entity_index(blip)
            if entity ~= 0 then
                entities.delete_by_handle(entity)
            end
        end
    end

    function RequestService(service)
        switch service do
            case 'NanoDrone':
                local drone = Globals.RequestNanoDrone:g()
                memory.write_int(drone, memory.read_int(drone) | memory.bits.masks.RequestNanoDrone)
                break
            case 'RCBandito':
                memory.write_byte(self.RequestBase + Offsets.Bandito, 1)
                break
            case 'RCTank':
                memory.write_byte(self.RequestBase + Offsets.Tank, 1)
                util.yield(3500)
                self.tune:trigger()
                break
            case 'MOC':
                memory.write_byte(self.RequestBase + Offsets.MOC, 1)
                break
            case 'Avenger':
                memory.write_byte(self.RequestBase + Offsets.Avenger, 1)
                break
            case 'AcidLab':
                memory.write_byte(self.RequestBase + Offsets.AcidLab, 1)
                break
            case 'Terrorbyte':
                memory.write_byte(self.RequestBase + Offsets.Terrorbyte, 1)
                break
            case 'Dinghy':
                memory.write_byte(self.RequestBase + Offsets.Dinghy, 1)
                break
            case 'Kosatka':
                memory.write_byte(self.RequestBase + Offsets.Kosatka, 1)
                break
            case 'Sparrow':
                memory.write_byte(self.AmPiMenuBase + Offsets.Sparrow, 1)
                break
            case 'Avisa':
                memory.write_byte(self.AmPiMenuBase + Offsets.Avisa, 1)
                break
            case 'BallisticArmor':
                memory.write_byte(self.RequestBase + Offsets.BallisticArmor, 1)
                break
            case 'AmmoDrop':
                memory.write_byte(self.RequestBase + Offsets.AmmoDrop, 1)
                break
            case 'Helicopter':
                memory.write_byte(self.RequestBase + Offsets.Helicopter, 1)
                break
            case 'DeliveryBike':
                memory.write_byte(self.RequestBase + Offsets.DeliveryBike, 1)
                break
            case 'RatBike':
                memory.write_byte(self.AmPiMenuBase + Offsets.RatBike, 1)
                break
            case 'AvengerThruster':
                memory.write_byte(self.AmPiMenuBase + Offsets.AvengerThruster, 1)
                break
            case 'Airstrike':
                stats.set_packed_stat_bool_code(8, true, util.get_char_slot())
                memory.write_byte(self.RequestBase + Offsets.Airstrike, 1)
                break
            case 'BackupHeli':
                stats.set_packed_stat_bool_code(11, true, util.get_char_slot())
                memory.write_byte(self.RequestBase + Offsets.BackupHeli, 1)
                break
            case 'BST':
                memory.write_byte(self.RequestBase + Offsets.BST, 1)
                break
            case 'Supplies':
                local supplies = Globals.RequestSupplies:g()
                local timer = Globals.RequestSuppliesTimer:g()
                memory.write_short(supplies, memory.read_short(supplies) | memory.bits.masks.RequestSupplies)
                util.yield(500)
                memory.write_int(timer, 0)
                break
            case 'SourceMotorcycle':
                memory.write_byte(Globals.SourceMotorcycle:g(), 1)
                break

        end
    end

    function SendNotif(func, ...)
        for pid = 0, players.max_players do
            if S:PlayerExists(pid) then
                if Settings:IsSet(Bits.ExcludeSelf) and pid == players.user() then
                    goto continue
                elseif Settings:IsSet(Bits.ExcludeFriends) and S:IsFriend(pid) then
                    goto continue
                end
                func(S, pid, ...)
            end
            ::continue::
        end
    end

    function LesterLocate(bit)
        local lester = Globals.LesterLocate:g()
        memory.write_byte(lester, memory.bits:toggle(memory.read_byte(lester), bit))
        util.yield_once()
        memory.write_byte(lester, memory.bits:toggle(memory.read_byte(lester), bit))
    end

    function RequestPegasusVehicle(hash)
        -- credit to acjoker for finding the globals that made this possible
        if not streaming.is_model_valid(hash) then Notifications.Show(T'Invalid Model Hash', 'MrRobot', '', Notifications.HUD_COLOUR_BLACK) return end
        local request = Globals.PegasusRequest:g()
        local request1 = request + 0x8
        memory.write_int(request1, hash)
        memory.write_byte(request, memory.bits:toggle(memory.read_byte(request), 1 << 7))
        util.yield_once()
        memory.write_byte(request, memory.bits:toggle(memory.read_byte(request), 1 << 7))
    end

    function RequestCEOVehicle(hash)
        if not streaming.is_model_valid(hash) then Notifications.Show(T'Invalid Model Hash', 'MrRobot', '', Notifications.HUD_COLOUR_BLACK) return end
        local request = Globals.OrganisationBase:g() + 0x50
        memory.write_int(request + CEOVehicle.VehicleHash, hash)
        memory.write_byte(request + CEOVehicle.Request, 1)
    end

    function RenameAcidLab(name)
        memory.write_string(Globals.AcidLabName:g(), name)
    end
    
    function GetAcidLabName()
        return memory.read_string(Globals.AcidLabName:g(players.user()))
    end
end

return Online
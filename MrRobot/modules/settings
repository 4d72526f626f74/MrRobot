local T, S = require('translations'), require('shared')
local G = require('script_globals')
local Globals = G.globals

local SettingsBits = S.SettingsBits

pluto_class Settings
    function __construct(root, version, settings)
        self.root = root:list(T'Settings', {T'rsettings'}, '')
        self.dll_path = ''

        if not S.Settings:IsSet(SettingsBits.Developer) then
            self.root:divider($'v{version}')
        else
            self.root:divider($'v{version}-dev')
        end
        root:divider('')

        self.remove_transaction_errors = self.root:toggle_loop(T'Remove Transaction Errors', {}, T'Removes annoying transaction error notifications', || -> memory.write_byte(Globals.TransactionErrorNotification:g(), 0))

        self.show_alerts = self.root:toggle(T'Show Alerts', {}, T'Should alerts be shown? (enabling this will force alerts to be sent to console instead of displaying)', function(state)
            S.Settings:SetBool(SettingsBits.ShowAlerts, state)
        end, S.Settings:IsSet(SettingsBits.ShowAlerts))

        self.root:toggle(T'Suppress Request Control Failures', {}, T'Should the failed to request control message be displayed?', function(state)
            S.Settings:SetBool(SettingsBits.SuppressRequestControlFailures, state)
        end, S.Settings:IsSet(SettingsBits.SuppressRequestControlFailures))

        self.remove_transaction_errors.value = S.Settings:IsSet(SettingsBits.RemoveTransactionError)
        self.root:toggle(T'Show Risky Options', {}, T'Will risky options be visible or not?', function(state)
            S.Settings:SetBool(SettingsBits.ShowRiskyOptions, state)
        end, S.Settings:IsSet(SettingsBits.ShowRiskyOptions))

        if S.Settings:IsSet(SettingsBits.Developer) then
            self.player_overlay = self.root:toggle(T'Enable Player Overlay', {}, T'Enables the player overlay', function(state)
                S.Settings:SetBool(SettingsBits.EnablePlayerOverlay, state)
            end, S.Settings:IsSet(SettingsBits.EnablePlayerOverlay))
        else
            S.Settings:SetBool(SettingsBits.EnablePlayerOverlay, false)
        end

        self.root:divider('')
        self.cache = self.root:list(T'Globals Cache', {T'settings'}, '')
        self.globals_cache = self.cache:toggle(T'Cache Globals', {}, T'Should script globals be cached or not?', function(state)
            S.Settings:SetBool(SettingsBits.CacheGlobals, state)
        end, S.Settings:IsSet(SettingsBits.CacheGlobals))

        self.cache:toggle_loop(T'Show Timer', {}, '', function()
            local time_left = (S.ClearCache.LastClear - os.time())
            util.draw_debug_text($'Time Remaining: {time_left} seconds')
        end)

        self.cache:slider(T'Cache Timer', {T'scachetimer'}, T'How long should globals be cached for? (in seconds)', 1, 3600, 600, 1, function(value)
            S.ClearCache.ClearTime = value
        end)

        self.cache:divider('')
        self.cache:action(T'Clear Globals Cache', {T'sclrgcache'}, T'Clears the cache for globals, use this if a feature is not working such as invisibility in self', function()
            S.ClearCache.ShouldClear = true
        end)

        self.modules = self.root:list(T'Modules', {T'rsmodules'}, T'Enable/disable loading of certain modules, this takes effect after restarting the script', nil, || -> self:SaveSettings(settings))
        self.loading_order = self.modules:list_select(T'Loading Order', {}, T'Order the modules are loaded in (credits and settings are unaffected by these changes)', {
            {1, 'Default'},
            {2, 'Ascending'},
            {3, 'Descending'},
            {4, 'Length (Shortest First)'},
            {5, 'Length (Longest First)'}
        }, 1, function(value)
            settings.loading_order = value
        end)
        self.loading_order.value = settings.loading_order
        self.modules:divider('')
        
        for k, v in pairs(settings.modules) do
            self.modules:toggle(k:gsub('^%l', string.upper), {}, '', function(state)
                settings.modules[k] = state
            end, v)
        end

        self.experimental = self.root:list(T'Experimental', {T'rexperimental'}, T'Experimental features that may have unintended behaviour')
        self.experimental:text_input(T'DLL Path', {T'rdllpath'}, T'Path to the DLL to load', function(value)
           self.dll_path = value
        end, self.dll_path)

        self.experimental:action(T'Load DLL', {T'rloaddll'}, T'Loads the DLL from the path specified', function()
            if self.dll_path ~= '' then
                if filesystem.exists(self.dll_path) then
                    local LoadLibraryA = S:GetProcAddressEx('LoadLibraryA')
                    if LoadLibraryA ~= 0 then
                        local name = self.dll_path:match('%w+.dll$')
                        local status, result = pcall(function()
                            local base = memory.scan(name)

                            if not base then
                                util.call_foreign_function(LoadLibraryA, self.dll_path)
                                base = memory.scan(name, '')
                                util.toast($'Loaded {name} at {string.format("0x%X", base)}')
                            else
                                util.toast($'{name} is already loaded at {string.format("0x%X", base)}')
                            end
                        end)

                        if not status then
                            util.toast($'Failed to load DLL: {result}')
                        end
                    end
                else
                    util.toast('DLL path does not exist')
                end
            else
                util.toast('No DLL path specified')
            end
        end)
    end

    function SaveSettings(settings)
        if filesystem.exists(filesystem.script_root() .. '/config/settings.json') then
            local file <close> = assert(io.open(filesystem.script_root() .. '/config/settings.json', 'w'))
            file:write(soup.json.encode(settings, true))
            file:close()
        end
    end
end

return Settings